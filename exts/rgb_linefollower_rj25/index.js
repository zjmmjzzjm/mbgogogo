(function(_,e){if("function"==typeof define&&define.amd)define(["exports"],e);else if("undefined"!=typeof exports)e(exports);else{var S={exports:{}};e(S.exports),_.unknown=S.exports}})(this,function(_){"use strict";function e(_,e){for(var S,O=0;O<e.length;O++)S=e[O],S.enumerable=S.enumerable||!1,S.configurable=!0,"value"in S&&(S.writable=!0),Object.defineProperty(_,S.key,S)}function S(_,S,O){return S&&e(_.prototype,S),O&&e(_,O),_}function O(_,e){return e&&("object"===I(e)||"function"==typeof e)?e:L(_)}function L(_){if(void 0===_)throw new ReferenceError("this hasn't been initialised - super() hasn't been called");return _}function R(_){return R=Object.setPrototypeOf?Object.getPrototypeOf:function(_){return _.__proto__||Object.getPrototypeOf(_)},R(_)}function t(_,e){if("function"!=typeof e&&null!==e)throw new TypeError("Super expression must either be null or a function");_.prototype=Object.create(e&&e.prototype,{constructor:{value:_,writable:!0,configurable:!0}}),e&&r(_,e)}function r(_,e){return r=Object.setPrototypeOf||function(_,e){return _.__proto__=e,_},r(_,e)}function o(_,e){if(!l(_,e))throw new TypeError("Cannot call a class as a function")}function N(_){return E(_)||n(_)||i()}function i(){throw new TypeError("Invalid attempt to spread non-iterable instance")}function n(_){if(Symbol.iterator in Object(_)||"[object Arguments]"===Object.prototype.toString.call(_))return Array.from(_)}function E(_){if(Array.isArray(_)){for(var e=0,S=Array(_.length);e<_.length;e++)S[e]=_[e];return S}}function T(_,e,S,O,L,R,t){try{var r=_[R](t),o=r.value}catch(_){return void S(_)}r.done?e(o):Promise.resolve(o).then(O,L)}function a(_){return function(){var e=this,S=arguments;return new Promise(function(O,L){function R(_){T(r,O,L,R,t,"next",_)}function t(_){T(r,O,L,R,t,"throw",_)}var r=_.apply(e,S);R(void 0)})}}function l(_,e){return null!=e&&"undefined"!=typeof Symbol&&e[Symbol.hasInstance]?e[Symbol.hasInstance](_):_ instanceof e}function I(_){return I="function"==typeof Symbol&&"symbol"==typeof Symbol.iterator?function(_){return typeof _}:function(_){return _&&"function"==typeof Symbol&&_.constructor===Symbol&&_!==Symbol.prototype?"symbol":typeof _},I(_)}Object.defineProperty(_,"__esModule",{value:!0}),_.default=void 0,!function(_){function e(_,e,S,L){var R=e&&l(e.prototype,O)?e:O,t=Object.create(R.prototype),r=new E(L||[]);return t._invoke=o(_,S,r),t}function S(_,e,S){try{return{type:"normal",arg:_.call(e,S)}}catch(_){return{type:"throw",arg:_}}}function O(){}function L(){}function R(){}function t(_){["next","throw","return"].forEach(function(e){_[e]=function(_){return this._invoke(e,_)}})}function r(_){function e(O,L,R,t){var r=S(_[O],_,L);if("throw"===r.type)t(r.arg);else{var o=r.arg,N=o.value;return N&&"object"===I(N)&&B.call(N,"__await")?Promise.resolve(N.__await).then(function(_){e("next",_,R,t)},function(_){e("throw",_,R,t)}):Promise.resolve(N).then(function(_){o.value=_,R(o)},function(_){return e("throw",_,R,t)})}}function O(_,S){function O(){return new Promise(function(O,L){e(_,S,O,L)})}return L=L?L.then(O,O):O()}var L;this._invoke=O}function o(_,e,O){var L="suspendedStart";return function(R,t){if(L==="executing")throw new Error("Generator is already running");if("completed"===L){if("throw"===R)throw t;return a()}for(O.method=R,O.arg=t;;){var r=O.delegate;if(r){var o=N(r,O);if(o){if(o===c)continue;return o}}if("next"===O.method)O.sent=O._sent=O.arg;else if("throw"===O.method){if("suspendedStart"===L)throw L="completed",O.arg;O.dispatchException(O.arg)}else"return"===O.method&&O.abrupt("return",O.arg);L="executing";var i=S(_,e,O);if("normal"===i.type){if(L=O.done?"completed":"suspendedYield",i.arg===c)continue;return{value:i.arg,done:O.done}}"throw"===i.type&&(L="completed",O.method="throw",O.arg=i.arg)}}}function N(_,e){var O=_.iterator[e.method];if(void 0===O){if(e.delegate=null,"throw"===e.method){if(_.iterator.return&&(e.method="return",e.arg=void 0,N(_,e),"throw"===e.method))return c;e.method="throw",e.arg=new TypeError("The iterator does not provide a 'throw' method")}return c}var L=S(O,_.iterator,e.arg);if("throw"===L.type)return e.method="throw",e.arg=L.arg,e.delegate=null,c;var R=L.arg;if(!R)return e.method="throw",e.arg=new TypeError("iterator result is not an object"),e.delegate=null,c;if(R.done)e[_.resultName]=R.value,e.next=_.nextLoc,"return"!==e.method&&(e.method="next",e.arg=void 0);else return R;return e.delegate=null,c}function i(_){var e={tryLoc:_[0]};1 in _&&(e.catchLoc=_[1]),2 in _&&(e.finallyLoc=_[2],e.afterLoc=_[3]),this.tryEntries.push(e)}function n(_){var e=_.completion||{};e.type="normal",delete e.arg,_.completion=e}function E(_){this.tryEntries=[{tryLoc:"root"}],_.forEach(i,this),this.reset(!0)}function T(_){if(_){var e=_[u];if(e)return e.call(_);if("function"==typeof _.next)return _;if(!isNaN(_.length)){var S=-1,O=function e(){for(;++S<_.length;)if(B.call(_,S))return e.value=_[S],e.done=!1,e;return e.value=void 0,e.done=!0,e};return O.next=O}}return{next:a}}function a(){return{value:void 0,done:!0}}var G=Object.prototype,B=G.hasOwnProperty,s="function"==typeof Symbol?Symbol:{},u=s.iterator||"@@iterator",d=s.asyncIterator||"@@asyncIterator",F=s.toStringTag||"@@toStringTag",p="object"===("undefined"==typeof module?"undefined":I(module)),A=_.regeneratorRuntime;if(A)return void(p&&(module.exports=A));A=_.regeneratorRuntime=p?module.exports||{}:{},A.wrap=e;var c={},W={};W[u]=function(){return this};var D=Object.getPrototypeOf,U=D&&D(D(T([])));U&&U!==G&&B.call(U,u)&&(W=U);var f=R.prototype=O.prototype=Object.create(W);L.prototype=f.constructor=R,R.constructor=L,R[F]=L.displayName="GeneratorFunction",A.isGeneratorFunction=function(_){var e="function"==typeof _&&_.constructor;return!!e&&(e===L||"GeneratorFunction"===(e.displayName||e.name))},A.mark=function(_){return Object.setPrototypeOf?Object.setPrototypeOf(_,R):(_.__proto__=R,!(F in _)&&(_[F]="GeneratorFunction")),_.prototype=Object.create(f),_},A.awrap=function(_){return{__await:_}},t(r.prototype),r.prototype[d]=function(){return this},A.AsyncIterator=r,A.async=function(_,S,O,L){var R=new r(e(_,S,O,L));return A.isGeneratorFunction(S)?R:R.next().then(function(_){return _.done?_.value:R.next()})},t(f),f[F]="Generator",f[u]=function(){return this},f.toString=function(){return"[object Generator]"},A.keys=function(_){var e=[];for(var S in _)e.push(S);return e.reverse(),function S(){for(;e.length;){var O=e.pop();if(O in _)return S.value=O,S.done=!1,S}return S.done=!0,S}},A.values=T,E.prototype={constructor:E,reset:function S(_){if(this.prev=0,this.next=0,this.sent=this._sent=void 0,this.done=!1,this.delegate=null,this.method="next",this.arg=void 0,this.tryEntries.forEach(n),!_)for(var e in this)"t"===e.charAt(0)&&B.call(this,e)&&!isNaN(+e.slice(1))&&(this[e]=void 0)},stop:function S(){this.done=!0;var _=this.tryEntries[0],e=_.completion;if("throw"===e.type)throw e.arg;return this.rval},dispatchException:function o(_){function e(e,O){return R.type="throw",R.arg=_,S.next=e,O&&(S.method="next",S.arg=void 0),!!O}if(this.done)throw _;for(var S=this,O=this.tryEntries.length-1;0<=O;--O){var L=this.tryEntries[O],R=L.completion;if("root"===L.tryLoc)return e("end");if(L.tryLoc<=this.prev){var t=B.call(L,"catchLoc"),r=B.call(L,"finallyLoc");if(t&&r){if(this.prev<L.catchLoc)return e(L.catchLoc,!0);if(this.prev<L.finallyLoc)return e(L.finallyLoc)}else if(t){if(this.prev<L.catchLoc)return e(L.catchLoc,!0);}else if(!r)throw new Error("try statement without catch or finally");else if(this.prev<L.finallyLoc)return e(L.finallyLoc)}}},abrupt:function t(_,e){for(var S,O=this.tryEntries.length-1;0<=O;--O)if(S=this.tryEntries[O],S.tryLoc<=this.prev&&B.call(S,"finallyLoc")&&this.prev<S.finallyLoc){var L=S;break}L&&("break"===_||"continue"===_)&&L.tryLoc<=e&&e<=L.finallyLoc&&(L=null);var R=L?L.completion:{};return R.type=_,R.arg=e,L?(this.method="next",this.next=L.finallyLoc,c):this.complete(R)},complete:function S(_,e){if("throw"===_.type)throw _.arg;return"break"===_.type||"continue"===_.type?this.next=_.arg:"return"===_.type?(this.rval=this.arg=_.arg,this.method="return",this.next="end"):"normal"===_.type&&e&&(this.next=e),c},finish:function O(_){for(var e,S=this.tryEntries.length-1;0<=S;--S)if(e=this.tryEntries[S],e.finallyLoc===_)return this.complete(e.completion,e.afterLoc),n(e),c},catch:function R(_){for(var e,S=this.tryEntries.length-1;0<=S;--S)if(e=this.tryEntries[S],e.tryLoc===_){var O=e.completion;if("throw"===O.type){var L=O.arg;n(e)}return L}throw new Error("illegal catch attempt")},delegateYield:function O(_,e,S){return this.delegate={iterator:T(_),resultName:e,nextLoc:S},"next"===this.method&&(this.arg=void 0),c}}}(function(){return this||"object"===("undefined"==typeof self?"undefined":I(self))&&self}()||Function("return this")());var G={zh:{rgb_linefollower_rj25:"RGB\u5DE1\u7EBF\u4F20\u611F\u5668",extensionName:"RGB\u5DE1\u7EBF\u4F20\u611F\u5668",extensionDescription:"RGB\u5DE1\u7EBF\u4F20\u611F\u5668",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"\u63A5\u53E31",RGB_LINEFOLLOW_INIT_PORT_1:"\u63A5\u53E32",RGB_LINEFOLLOW_INIT_PORT_2:"\u63A5\u53E33",RGB_LINEFOLLOW_INIT_PORT_3:"\u63A5\u53E34",RGB_LINEFOLLOW_INIT_PORT_4:"\u63A5\u53E35",RGB_LINEFOLLOW_INIT_PORT_5:"\u63A5\u53E36",RGB_LINEFOLLOW_INIT_PORT_6:"\u63A5\u53E37",RGB_LINEFOLLOW_INIT_PORT_7:"\u63A5\u53E38",RGB_LINEFOLLOW_INIT_PORT_8:"\u63A5\u53E39",RGB_LINEFOLLOW_INIT_PORT_9:"\u63A5\u53E310",RGB_LINEFOLLOW_INIT_PORT_10:"\u63A5\u53E311",RGB_LINEFOLLOW_INIT_PORT_11:"\u63A5\u53E312",rgb_linefollow_init:"\u521D\u59CB\u5316RGB\u5DE1\u7EBF\u4F20\u611F\u5668 [SENSOR_ID] \uFF1A \u4F4D\u4E8E [PORT]",rgb_linefollow_turning_sens:"RGB\u5DE1\u7EBF\u4F20\u611F\u5668 [SENSOR_ID] \uFF1A \uFF08\u9ED8\u8BA4\u5DE1\u7EBF\u7B56\u7565\uFF09\u8BBE\u7F6E\u8F6C\u5411\u7075\u654F\u5EA6 [SENS]",rgb_linefollow_speed_diff:"RGB\u5DE1\u7EBF\u4F20\u611F\u5668 [SENSOR_ID] \uFF1A \uFF08\u9ED8\u8BA4\u5DE1\u7EBF\u7B56\u7565\uFF09\u7535\u673A\u5DEE\u901F",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"RGB\u5DE1\u7EBF\u4F20\u611F\u5668 [SENSOR_ID] \uFF1A \u63A2\u5934\u72B6\u6001\u4E3A\uFF08RGB4~RGB1\uFF09 [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB\u5DE1\u7EBF\u4F20\u611F\u5668 [SENSOR_ID] \uFF1A\u63A2\u5934 [CHANNEL] \u68C0\u6D4B\u5230\u80CC\u666F\u8272\uFF1F",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"\u7EA2",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"\u7EFF",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"\u84DD",rgb_linefollow_set_color:"RGB\u5DE1\u7EBF\u4F20\u611F\u5668 [SENSOR_ID] \uFF1A\u8BBE\u7F6E\u4F20\u611F\u5668\u654F\u611F\u989C\u8272\u53CA\u8865\u5149\u706F\u989C\u8272\u4E3A [COLOR]",rgb_linefollow_get_data:"RGB\u5DE1\u7EBF\u4F20\u611F\u5668 [SENSOR_ID] \uFF1A\u63A2\u5934 [CHANNEL] \u8FD4\u56DE\u503C",rgb_linefollow_sensor:"RGB\u5DE1\u7EBF\u4F20\u611F\u5668"},en:{rgb_linefollower_rj25:"RGB Line Follower",extensionName:"RGB Line Follower",extensionDescription:"RGB Line Follower",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"port1",RGB_LINEFOLLOW_INIT_PORT_1:"port2",RGB_LINEFOLLOW_INIT_PORT_2:"port3",RGB_LINEFOLLOW_INIT_PORT_3:"port4",RGB_LINEFOLLOW_INIT_PORT_4:"port5",RGB_LINEFOLLOW_INIT_PORT_5:"port6",RGB_LINEFOLLOW_INIT_PORT_6:"port7",RGB_LINEFOLLOW_INIT_PORT_7:"port8",RGB_LINEFOLLOW_INIT_PORT_8:"port9",RGB_LINEFOLLOW_INIT_PORT_9:"port10",RGB_LINEFOLLOW_INIT_PORT_10:"port11",RGB_LINEFOLLOW_INIT_PORT_11:"port12",rgb_linefollow_init:"initialize RGB line follower [SENSOR_ID] : at [PORT]",rgb_linefollow_turning_sens:"RGB line follower[SENSOR_ID] : (default line following) set turning sensitivity to [SENS]",rgb_linefollow_speed_diff:"RGB line follower[SENSOR_ID]: (default line following) motor differential speed",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"RGB line follower [SENSOR_ID]: probe status as (RGB4~RGB1) [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB line follower [SENSOR_ID]: probe[CHANNEL] detects background color?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"red",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"green",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"blue",rgb_linefollow_set_color:"RGB line follower [SENSOR_ID]: set target color and fill light to [COLOR]",rgb_linefollow_get_data:"RGB line follower [SENSOR_ID] : probe[CHANNEL] return value",rgb_linefollow_sensor:"RGB Line Follower"},de:{rgb_linefollower_rj25:"RGB Line Follower",extensionName:"RGB Line Follower",extensionDescription:"RGB Line Follower",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"port1",RGB_LINEFOLLOW_INIT_PORT_1:"port2",RGB_LINEFOLLOW_INIT_PORT_2:"port3",RGB_LINEFOLLOW_INIT_PORT_3:"port4",RGB_LINEFOLLOW_INIT_PORT_4:"port5",RGB_LINEFOLLOW_INIT_PORT_5:"port6",RGB_LINEFOLLOW_INIT_PORT_6:"port7",RGB_LINEFOLLOW_INIT_PORT_7:"port8",RGB_LINEFOLLOW_INIT_PORT_8:"port9",RGB_LINEFOLLOW_INIT_PORT_9:"port10",RGB_LINEFOLLOW_INIT_PORT_10:"port11",RGB_LINEFOLLOW_INIT_PORT_11:"port12",rgb_linefollow_init:"rGB line follower initialisieren [SENSOR_ID] : At [PORT]",rgb_linefollow_turning_sens:"RGB line follower [SENSOR_ID] : (Voreinstellung der Linie danach) drehende Empfindlichkeit auf [SENS]",rgb_linefollow_speed_diff:"RGB-Linienanh\xE4nger[SENSOR_ID]: (Standardlinie folgt) Motordifferenzgeschwindigkeit",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"RGB-Linienanh\xE4nger [SENSOR_ID]: Sondenstatus als (RGB4~RGB1) [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB line follower [SENSOR_ID]: Sonde[CHANNEL] Erkennt Hintergrundfarbe?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"rot",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"gr\xFCn",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"blau",rgb_linefollow_set_color:"RGB line follower [SENSOR_ID]: Zielfarbe einstellen und Licht ausf\xFCllen [COLOR]",rgb_linefollow_get_data:"RGB line follower [SENSOR_ID] : Sonde[CHANNEL] R\xFCckgabewert",rgb_linefollow_sensor:"RGB Line Follower"},es:{rgb_linefollower_rj25:"RGB Line Follower",extensionName:"RGB Line Follower",extensionDescription:"RGB Line Follower",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"puerto1",RGB_LINEFOLLOW_INIT_PORT_1:"puerto2",RGB_LINEFOLLOW_INIT_PORT_2:"puerto3",RGB_LINEFOLLOW_INIT_PORT_3:"puerto4",RGB_LINEFOLLOW_INIT_PORT_4:"puerto5",RGB_LINEFOLLOW_INIT_PORT_5:"puerto6",RGB_LINEFOLLOW_INIT_PORT_6:"puerto7",RGB_LINEFOLLOW_INIT_PORT_7:"puerto8",RGB_LINEFOLLOW_INIT_PORT_8:"puerto9",RGB_LINEFOLLOW_INIT_PORT_9:"puerto10",RGB_LINEFOLLOW_INIT_PORT_10:"puerto11",RGB_LINEFOLLOW_INIT_PORT_11:"puerto12",rgb_linefollow_init:"inicializar seguidor de l\xEDnea RGB [SENSOR_ID] : en [PORT]",rgb_linefollow_turning_sens:"Seguidor de l\xEDnea RGB[SENSOR_ID] : (siguiente l\xEDnea por defecto) establece la sensibilidad [SENS]",rgb_linefollow_speed_diff:"siguel\xEDneas RGB [SENSOR_ID]: (seguimiento de l\xEDnea por defecto) velocidad diferencial del motor",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"siguel\xEDneas RGB [SENSOR_ID]: estado del sensor en (RGB4-RGB1) [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"Seguidor de l\xEDnea RGB [SENSOR_ID]: sonda[CHANNEL] detecta el color de fondo?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"rojo",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"verde",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"azul",rgb_linefollow_set_color:"Seguidor de l\xEDnea RGB [SENSOR_ID]: defina el color de destino y la luz de relleno [COLOR]",rgb_linefollow_get_data:"Seguidor de l\xEDnea RGB [SENSOR_ID] : valor de sonda [CHANNEL]",rgb_linefollow_sensor:"Seguidor de l\xEDnea RGB"},fr:{rgb_linefollower_rj25:"RGB Line Follower",extensionName:"RGB Line Follower",extensionDescription:"RGB Line Follower",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"port 1",RGB_LINEFOLLOW_INIT_PORT_1:"port 2",RGB_LINEFOLLOW_INIT_PORT_2:"port 3",RGB_LINEFOLLOW_INIT_PORT_3:"port 4",RGB_LINEFOLLOW_INIT_PORT_4:"port 5",RGB_LINEFOLLOW_INIT_PORT_5:"port 6",RGB_LINEFOLLOW_INIT_PORT_6:"port 7",RGB_LINEFOLLOW_INIT_PORT_7:"port 8",RGB_LINEFOLLOW_INIT_PORT_8:"port 9",RGB_LINEFOLLOW_INIT_PORT_9:"port 10",RGB_LINEFOLLOW_INIT_PORT_10:"port 11",RGB_LINEFOLLOW_INIT_PORT_11:"port 12",rgb_linefollow_init:"initialiser le RGB line follower [SENSOR_ID] : \xE0 [PORT]",rgb_linefollow_turning_sens:"RGB line follower[SENSOR_ID] : (ligne par d\xE9faut suivante) R\xE9glez la sensibilit\xE9 [SENS]",rgb_linefollow_speed_diff:"Suiveur de ligne RGB[SENSOR_ID]: (ligne par d\xE9faut suivant) Vitesse diff\xE9rentielle du moteur",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"Suiveur de ligne RGB [SENSOR_ID]: \xE9tat de la sonde (RGB4 ~ RGB1) [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB line follower [SENSOR_ID]: sonde[CHANNEL] d\xE9tecte la couleur d'arri\xE8re-plan?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"rouge",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"vert",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"bleu",rgb_linefollow_set_color:"RGB line follower[SENSOR_ID]: d\xE9finissez la couleur de la cible et remplissez la lumi\xE8re pour [COLOR]",rgb_linefollow_get_data:"RGB line follower [SENSOR_ID] : sonde[CHANNEL] valeur de retour",rgb_linefollow_sensor:"RGB Line Follower"},id:{rgb_linefollower_rj25:"RGB Line Follower",extensionName:"RGB Line Follower",extensionDescription:"RGB Line Follower",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"port1",RGB_LINEFOLLOW_INIT_PORT_1:"port2",RGB_LINEFOLLOW_INIT_PORT_2:"port3",RGB_LINEFOLLOW_INIT_PORT_3:"port4",RGB_LINEFOLLOW_INIT_PORT_4:"port5",RGB_LINEFOLLOW_INIT_PORT_5:"port6",RGB_LINEFOLLOW_INIT_PORT_6:"port7",RGB_LINEFOLLOW_INIT_PORT_7:"port8",RGB_LINEFOLLOW_INIT_PORT_8:"port9",RGB_LINEFOLLOW_INIT_PORT_9:"port10",RGB_LINEFOLLOW_INIT_PORT_10:"port11",RGB_LINEFOLLOW_INIT_PORT_11:"port12",rgb_linefollow_init:"menginisialisasi RGB line follower[SENSOR_ID] : di [PORT]",rgb_linefollow_turning_sens:"RGB line follower[SENSOR_ID] : (default baris berikut) mengatur berbalik sensitivitas [SENS]",rgb_linefollow_speed_diff:"RGB baris pengikut[SENSOR_ID]: (default baris berikut) diferensial kecepatan motor",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"RGB baris pengikut [SENSOR_ID]: probe status sebagai (RGB4 ~ RGB1) [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB line follower[SENSOR_ID]: probe[CHANNEL] mendeteksi warna latar belakang?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"merah",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"hijau",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"biru",rgb_linefollow_set_color:"RGB line follower [SENSOR_ID]: menetapkan sasaran warna dan mengisi cahaya untuk [COLOR]",rgb_linefollow_get_data:"RGB line follower [SENSOR_ID] : probe[CHANNEL] mengembalikan nilai",rgb_linefollow_sensor:"RGB Line Follower"},ja:{rgb_linefollower_rj25:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9",extensionName:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9",extensionDescription:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"\u30DD\u30FC\u30C81",RGB_LINEFOLLOW_INIT_PORT_1:"\u30DD\u30FC\u30C82",RGB_LINEFOLLOW_INIT_PORT_2:"\u30DD\u30FC\u30C83",RGB_LINEFOLLOW_INIT_PORT_3:"\u30DD\u30FC\u30C84",RGB_LINEFOLLOW_INIT_PORT_4:"\u30DD\u30FC\u30C85",RGB_LINEFOLLOW_INIT_PORT_5:"\u30DD\u30FC\u30C86",RGB_LINEFOLLOW_INIT_PORT_6:"\u30DD\u30FC\u30C87",RGB_LINEFOLLOW_INIT_PORT_7:"\u30DD\u30FC\u30C88",RGB_LINEFOLLOW_INIT_PORT_8:"\u30DD\u30FC\u30C89",RGB_LINEFOLLOW_INIT_PORT_9:"\u30DD\u30FC\u30C810",RGB_LINEFOLLOW_INIT_PORT_10:"\u30DD\u30FC\u30C811",RGB_LINEFOLLOW_INIT_PORT_11:"\u30DD\u30FC\u30C812",rgb_linefollow_init:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9\u306E\u521D\u671F\u5316 [SENSOR_ID] : [PORT]",rgb_linefollow_turning_sens:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9[SENSOR_ID]\uFF1A\uFF08\u30C7\u30D5\u30A9\u30EB\u30C8\u306E\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9\uFF09\u56DE\u8EE2\u611F\u5EA6\u3092[SENS] \u306B\u8A2D\u5B9A\u3059\u308B",rgb_linefollow_speed_diff:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9[SENSOR_ID]\uFF1A\uFF08\u30C7\u30D5\u30A9\u30EB\u30C8\u306E\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9\u306E\uFF09\u30E2\u30FC\u30BF\u30FC\u306E\u5DEE\u52D5\u901F\u5EA6",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9 [SENSOR_ID]\uFF1A\u30D7\u30ED\u30FC\u30D6\u306E\u72B6\u614B \u3092(RGB4~RGB1) [SENSOR_STATUS] \u306B\u8A2D\u5B9A\u3059\u308B",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9 [SENSOR_ID]\uFF1A\u30D7\u30ED\u30FC\u30D6[CHANNEL] \u304C\u80CC\u666F\u8272\u3092\u691C\u51FA\u3059\u308B",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"\u8D64",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"\u7DD1",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"\u9752",rgb_linefollow_set_color:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9 [SENSOR_ID]\uFF1A\u5BFE\u8C61\u8272\u3068\u30D5\u30A3\u30EB\u30E9\u30A4\u30C8\u3092[COLOR] \u8272\u306B\u8A2D\u5B9A\u3059\u308B",rgb_linefollow_get_data:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9 [SENSOR_ID]\uFF1A\u30D7\u30ED\u30FC\u30D6[CHANNEL] \u306E\u623B\u308A\u5024",rgb_linefollow_sensor:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9"},"ja-jph":{rgb_linefollower_rj25:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9",extensionName:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9",extensionDescription:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"\u30DD\u30FC\u30C81",RGB_LINEFOLLOW_INIT_PORT_1:"\u30DD\u30FC\u30C82",RGB_LINEFOLLOW_INIT_PORT_2:"\u30DD\u30FC\u30C83",RGB_LINEFOLLOW_INIT_PORT_3:"\u30DD\u30FC\u30C84",RGB_LINEFOLLOW_INIT_PORT_4:"\u30DD\u30FC\u30C85",RGB_LINEFOLLOW_INIT_PORT_5:"\u30DD\u30FC\u30C86",RGB_LINEFOLLOW_INIT_PORT_6:"\u30DD\u30FC\u30C87",RGB_LINEFOLLOW_INIT_PORT_7:"\u30DD\u30FC\u30C88",RGB_LINEFOLLOW_INIT_PORT_8:"\u30DD\u30FC\u30C89",RGB_LINEFOLLOW_INIT_PORT_9:"\u30DD\u30FC\u30C810",RGB_LINEFOLLOW_INIT_PORT_10:"\u30DD\u30FC\u30C811",RGB_LINEFOLLOW_INIT_PORT_11:"\u30DD\u30FC\u30C812",rgb_linefollow_init:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9\u306E\u3057\u3087\u304D\u304B [SENSOR_ID] : [PORT]",rgb_linefollow_turning_sens:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9[SENSOR_ID]\uFF1A\uFF08\u30C7\u30D5\u30A9\u30EB\u30C8\u306E\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9\uFF09\u304B\u3044\u3066\u3093\u304B\u3093\u3069\u3092[SENS] \u306B\u305B\u3063\u3066\u3044\u3059\u308B",rgb_linefollow_speed_diff:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9[SENSOR_ID]\uFF1A\uFF08\u30C7\u30D5\u30A9\u30EB\u30C8\u306E\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9\u306E\uFF09\u30E2\u30FC\u30BF\u30FC\u306E\u3055\u3069\u3046\u305D\u304F\u3069",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9 [SENSOR_ID]\uFF1A\u30D7\u30ED\u30FC\u30D6\u306E\u3058\u3087\u3046\u305F\u3044 \u3092(RGB4~RGB1) [SENSOR_STATUS] \u306B\u305B\u3063\u3066\u3044\u3059\u308B",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9 [SENSOR_ID]\uFF1A\u30D7\u30ED\u30FC\u30D6[CHANNEL] \u304C\u306F\u3044\u3051\u3044\u3057\u3087\u304F\u3092\u3051\u3093\u3057\u3085\u3064\u3059\u308B",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"\u3042\u304B",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"\u307F\u3069\u308A",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"\u3042\u304A",rgb_linefollow_set_color:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9 [SENSOR_ID]\uFF1A\u305F\u3044\u3057\u3087\u3046\u3044\u308D\u3068\u30D5\u30A3\u30EB\u30E9\u30A4\u30C8\u3092[COLOR] \u3044\u308D\u306B\u305B\u3063\u3066\u3044\u3059\u308B",rgb_linefollow_get_data:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9 [SENSOR_ID]\uFF1A\u30D7\u30ED\u30FC\u30D6[CHANNEL] \u306E\u3082\u3069\u308A\u3061",rgb_linefollow_sensor:"RGB\u30E9\u30A4\u30F3\u30C8\u30EC\u30FC\u30B9"},ko:{rgb_linefollower_rj25:"RGB \uC120 \uD314\uB85C \uC6CC",extensionName:"RGB \uC120 \uD314\uB85C \uC6CC",extensionDescription:"RGB \uC120 \uD314\uB85C \uC6CC",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"\uD3EC\uD2B81",RGB_LINEFOLLOW_INIT_PORT_1:"\uD3EC\uD2B82",RGB_LINEFOLLOW_INIT_PORT_2:"\uD3EC\uD2B83",RGB_LINEFOLLOW_INIT_PORT_3:"\uD3EC\uD2B84",RGB_LINEFOLLOW_INIT_PORT_4:"\uD3EC\uD2B85",RGB_LINEFOLLOW_INIT_PORT_5:"\uD3EC\uD2B86",RGB_LINEFOLLOW_INIT_PORT_6:"\uD3EC\uD2B87",RGB_LINEFOLLOW_INIT_PORT_7:"\uD3EC\uD2B88",RGB_LINEFOLLOW_INIT_PORT_8:"\uD3EC\uD2B89",RGB_LINEFOLLOW_INIT_PORT_9:"\uD3EC\uD2B810",RGB_LINEFOLLOW_INIT_PORT_10:"\uD3EC\uD2B811",RGB_LINEFOLLOW_INIT_PORT_11:"\uD3EC\uD2B812",rgb_linefollow_init:"RGB \uC120 \uD314\uB85C \uC6CC \uCD08\uAE30\uD654 [SENSOR_ID] : at [PORT]",rgb_linefollow_turning_sens:"RGB \uC120 \uD314\uB85C \uC6CC[SENSOR_ID] : (\uAE30\uBCF8 \uC120 \uB2E4\uC74C) \uD68C\uC804 \uBBFC\uAC10\uB3C4\uB97C \uC124\uC815 \uD558 \uC5EC [SENS]",rgb_linefollow_speed_diff:"RGB \uC120 \uD314\uB85C \uC6CC[SENSOR_ID]: (\uAE30\uBCF8 \uB77C\uC778 \uB2E4\uC74C) \uBAA8\uD130 \uCC28\uB3D9 \uC18D\uB3C4",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"RGB \uC120 \uD314\uB85C \uC6CC [SENSOR_ID]: \uD504\uB85C\uBE0C \uC0C1\uD0DC (RGB4 ~ RGB1) [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB \uC120 \uD314\uB85C \uC6CC [SENSOR_ID]: \uD504\uB85C\uBE0C[CHANNEL] \uBC30\uACBD \uC0C9\uC0C1\uC744 \uAC10\uC9C0?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"\uBE68\uAC15",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"\uCD08\uB85D",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"\uD30C\uB791",rgb_linefollow_set_color:"RGB \uC120 \uD314\uB85C \uC6CC [SENSOR_ID]: \uB300\uC0C1 \uC0C9\uC0C1 \uBC0F \uCC44\uC6B0\uAE30 \uC870\uBA85 \uC124\uC815 [COLOR]",rgb_linefollow_get_data:"RGB \uC120 \uD314\uB85C \uC6CC [SENSOR_ID] : \uD504\uB85C\uBE0C[CHANNEL] \uBC18\uD658 \uAC12",rgb_linefollow_sensor:"RGB \uC120 \uD314\uB85C \uC6CC"},pl:{rgb_linefollower_rj25:"RGB Line Follower",extensionName:"RGB Line Followe",extensionDescription:"RGB Line Follower",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"port1",RGB_LINEFOLLOW_INIT_PORT_1:"port2",RGB_LINEFOLLOW_INIT_PORT_2:"port3",RGB_LINEFOLLOW_INIT_PORT_3:"port4",RGB_LINEFOLLOW_INIT_PORT_4:"port5",RGB_LINEFOLLOW_INIT_PORT_5:"port6",RGB_LINEFOLLOW_INIT_PORT_6:"port7",RGB_LINEFOLLOW_INIT_PORT_7:"port8",RGB_LINEFOLLOW_INIT_PORT_8:"port9",RGB_LINEFOLLOW_INIT_PORT_9:"port10",RGB_LINEFOLLOW_INIT_PORT_10:"port11",RGB_LINEFOLLOW_INIT_PORT_11:"port12",rgb_linefollow_init:"zainicjuj popychacz RGB line follower [SENSOR_ID] : at [PORT]",rgb_linefollow_turning_sens:"RGB line follower[SENSOR_ID] : (domy\u015Blna linia Poni\u017Csza) ustaw czu\u0142o\u015B\u0107 obracaj\u0105c [SENS]",rgb_linefollow_speed_diff:"Linia \u015Bladu RGB[SENSOR_ID]: (domy\u015Blna linia nast\u0119puj\u0105ca) pr\u0119dko\u015B\u0107 obrotowa silnika",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"Linia \u015Bladu RGB [SENSOR_ID]: Sonda stan jako (RGB4 ~ RGB1) [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB line follower [SENSOR_ID]: Probe[CHANNEL] wykrywa kolor t\u0142a?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"czerwony",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"zielony",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"niebieski",rgb_linefollow_set_color:"RGB line follower [SENSOR_ID]: Ustaw kolor docelowy i wype\u0142nienie [COLOR]",rgb_linefollow_get_data:"RGB line follower [SENSOR_ID] : Probe[CHANNEL] zwracanej warto\u015Bci",rgb_linefollow_sensor:"RGB Line Follower"},uk:{rgb_linefollower_rj25:"RGB \u0434\u0430\u0442\u0447\u0438\u043A \u0441\u043B\u0456\u0434\u0443\u0432\u0430\u043D\u043D\u044F \u0437\u0430 \u043B\u0456\u043D\u0456\u0454\u044E",extensionName:"RGB \u0434\u0430\u0442\u0447\u0438\u043A \u0441\u043B\u0456\u0434\u0443\u0432\u0430\u043D\u043D\u044F \u0437\u0430 \u043B\u0456\u043D\u0456\u0454\u044E",extensionDescription:"RGB \u0434\u0430\u0442\u0447\u0438\u043A \u0441\u043B\u0456\u0434\u0443\u0432\u0430\u043D\u043D\u044F \u0437\u0430 \u043B\u0456\u043D\u0456\u0454\u044E",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"\u043F\u043E\u0440\u0442 1",RGB_LINEFOLLOW_INIT_PORT_1:"\u043F\u043E\u0440\u0442 2",RGB_LINEFOLLOW_INIT_PORT_2:"\u043F\u043E\u0440\u0442 3",RGB_LINEFOLLOW_INIT_PORT_3:"\u043F\u043E\u0440\u0442 4",RGB_LINEFOLLOW_INIT_PORT_4:"\u043F\u043E\u0440\u0442 5",RGB_LINEFOLLOW_INIT_PORT_5:"\u043F\u043E\u0440\u0442 6",RGB_LINEFOLLOW_INIT_PORT_6:"\u043F\u043E\u0440\u0442 7",RGB_LINEFOLLOW_INIT_PORT_7:"\u043F\u043E\u0440\u0442 8",RGB_LINEFOLLOW_INIT_PORT_8:"\u043F\u043E\u0440\u0442 9",RGB_LINEFOLLOW_INIT_PORT_9:"\u043F\u043E\u0440\u0442 10",RGB_LINEFOLLOW_INIT_PORT_10:"\u043F\u043E\u0440\u0442 11",RGB_LINEFOLLOW_INIT_PORT_11:"\u043F\u043E\u0440\u0442 12",rgb_linefollow_init:"\u0456\u043D\u0456\u0446\u0456\u0430\u043B\u0456\u0437\u0430\u0446\u0456\u044F RGB \u0434\u0430\u0442\u0447\u0438\u043A\u0430 \u0441\u043B\u0456\u0434\u0443\u0432\u0430\u043D\u043D\u044F \u0437\u0430 \u043B\u0456\u043D\u0456\u0454\u044E [SENSOR_ID] [PORT]",rgb_linefollow_turning_sens:"RGB \u0434\u0430\u0442\u0447\u0438\u043A \u0441\u043B\u0456\u0434\u0443\u0432\u0430\u043D\u043D\u044F \u0437\u0430 \u043B\u0456\u043D\u0456\u0454\u044E [SENSOR_ID]: \u0432\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u0438 \u0447\u0443\u0442\u043B\u0438\u0432\u0456\u0441\u0442\u044C \u043F\u043E\u0432\u043E\u0440\u043E\u0442\u0443 [SENS]",rgb_linefollow_speed_diff:"RGB \u0434\u0430\u0442\u0447\u0438\u043A \u0441\u043B\u0456\u0434\u0443\u0432\u0430\u043D\u043D\u044F \u0437\u0430 \u043B\u0456\u043D\u0456\u0454\u044E [SENSOR_ID]: \u0448\u0432\u0438\u0434\u043A\u0456\u0441\u0442\u044C \u0434\u0438\u0444\u0435\u0440\u0435\u043D\u0446\u0456\u0430\u043B\u0443 \u043C\u043E\u0442\u043E\u0440\u0443",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"RGB \u0434\u0430\u0442\u0447\u0438\u043A \u0441\u043B\u0456\u0434\u0443\u0432\u0430\u043D\u043D\u044F \u0437\u0430 \u043B\u0456\u043D\u0456\u0454\u044E [SENSOR_ID]: \u0441\u0442\u0430\u0442\u0443\u0441 (RGB4 ~ RGB1) [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB \u0434\u0430\u0442\u0447\u0438\u043A \u0441\u043B\u0456\u0434\u0443\u0432\u0430\u043D\u043D\u044F \u0437\u0430 \u043B\u0456\u043D\u0456\u0454\u044E [SENSOR_ID]: \u043F\u0440\u043E\u0431\u0430 [CHANNEL] \u0432\u0438\u044F\u0432\u043B\u0435\u043D\u043E \u043A\u043E\u043B\u0456\u0440 \u0444\u043E\u043D\u0443?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"\u0447\u0435\u0440\u0432\u043E\u043D\u0438\u0439",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"\u0437\u0435\u043B\u0435\u043D\u0438\u0439",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"\u0441\u0438\u043D\u0456\u0439",rgb_linefollow_set_color:"RGB \u0434\u0430\u0442\u0447\u0438\u043A \u0441\u043B\u0456\u0434\u0443\u0432\u0430\u043D\u043D\u044F \u0437\u0430 \u043B\u0456\u043D\u0456\u0454\u044E [SENSOR_ID]: \u0432\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u0438 \u0446\u0456\u043B\u044C\u043E\u0432\u0438\u0439 \u043A\u043E\u043B\u0456\u0440 \u0456 \u0437\u0430\u043F\u043E\u0432\u043D\u0438\u0442\u0438 \u0444\u043E\u043D [COLOR]",rgb_linefollow_get_data:"RGB \u0434\u0430\u0442\u0447\u0438\u043A \u0441\u043B\u0456\u0434\u0443\u0432\u0430\u043D\u043D\u044F \u0437\u0430 \u043B\u0456\u043D\u0456\u0454\u044E [SENSOR_ID]: \u043F\u0440\u043E\u0431\u0430 [CHANNEL] \u043F\u043E\u0432\u0435\u0440\u043D\u0443\u0442\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u043D\u044F",rgb_linefollow_sensor:"RGB \u0434\u0430\u0442\u0447\u0438\u043A \u0441\u043B\u0456\u0434\u0443\u0432\u0430\u043D\u043D\u044F \u0437\u0430 \u043B\u0456\u043D\u0456\u0454\u044E"},"zh-hant":{rgb_linefollower_rj25:"RGB\u5FAA\u7DDA\u611F\u6E2C\u5668",extensionName:"RGB\u5FAA\u7DDA\u611F\u6E2C\u5668",extensionDescription:"RGB\u5FAA\u7DDA\u611F\u6E2C\u5668",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"\u9023\u63A5\u57E01",RGB_LINEFOLLOW_INIT_PORT_1:"\u9023\u63A5\u57E02",RGB_LINEFOLLOW_INIT_PORT_2:"\u9023\u63A5\u57E03",RGB_LINEFOLLOW_INIT_PORT_3:"\u9023\u63A5\u57E04",RGB_LINEFOLLOW_INIT_PORT_4:"\u9023\u63A5\u57E05",RGB_LINEFOLLOW_INIT_PORT_5:"\u9023\u63A5\u57E06",RGB_LINEFOLLOW_INIT_PORT_6:"\u9023\u63A5\u57E07",RGB_LINEFOLLOW_INIT_PORT_7:"\u9023\u63A5\u57E08",RGB_LINEFOLLOW_INIT_PORT_8:"\u9023\u63A5\u57E09",RGB_LINEFOLLOW_INIT_PORT_9:"\u9023\u63A5\u57E010",RGB_LINEFOLLOW_INIT_PORT_10:"\u9023\u63A5\u57E011",RGB_LINEFOLLOW_INIT_PORT_11:"\u9023\u63A5\u57E012",rgb_linefollow_init:"\u521D\u59CB\u5316RGB\u5FAA\u7DDA\u611F\u6E2C\u5668[SENSOR_ID] : at[PORT]",rgb_linefollow_turning_sens:"\u8A2D\u7F6ERGB\u5FAA\u7DDA\u611F\u6E2C\u5668[SENSOR_ID]:(\u9ED8\u8A8D\u5FAA\u7DDA\u7B56\u7565)\u8F49\u5411\u9748\u654F\u5EA6[SENS]",rgb_linefollow_speed_diff:"\u7372\u53D6RGB\u5FAA\u7DDA\u611F\u6E2C\u5668[SENSOR_ID]:(\u9ED8\u8A8D\u5FAA\u7DDA\u7B56\u7565) \u99AC\u9054\u901F\u5DEE",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"RGB\u5FAA\u7DDA\u611F\u6E2C\u5668[SENSOR_ID]: \u63A2\u982D\u72C0\u614B\u70BA\uFF08RGB4~RGB1\uFF09 [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB\u5FAA\u7DDA\u611F\u6E2C\u5668[SENSOR_ID]:\u63A2\u982D[CHANNEL]\u6AA2\u6E2C\u5230\u80CC\u666F\u8272?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"\u7D05\u8272",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"\u7DA0\u8272",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"\u85CD\u8272",rgb_linefollow_set_color:"RGB\u5FAA\u7DDA\u611F\u6E2C\u5668[SENSOR_ID]\u8A2D\u7F6E\u611F\u6E2C\u5668\u611F\u61C9\u984F\u8272\u53CA\u88DC\u5149\u71C8\u984F\u8272\u70BA[COLOR]",rgb_linefollow_get_data:"RGB\u5FAA\u7DDA\u611F\u6E2C\u5668[SENSOR_ID]:\u63A2\u982D[CHANNEL]\u56DE\u50B3\u503C",rgb_linefollow_sensor:"RGB\u5FAA\u7DDA\u611F\u6E2C\u5668"},nl:{rgb_linefollower_rj25:"RGB Lijnvolger",extensionName:"RGB Lijnvolger",extensionDescription:"RGB Lijnvolger",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"poort1",RGB_LINEFOLLOW_INIT_PORT_1:"poort2",RGB_LINEFOLLOW_INIT_PORT_2:"poort3",RGB_LINEFOLLOW_INIT_PORT_3:"poort4",RGB_LINEFOLLOW_INIT_PORT_4:"poort5",RGB_LINEFOLLOW_INIT_PORT_5:"poort6",RGB_LINEFOLLOW_INIT_PORT_6:"poort7",RGB_LINEFOLLOW_INIT_PORT_7:"poort8",RGB_LINEFOLLOW_INIT_PORT_8:"poort9",RGB_LINEFOLLOW_INIT_PORT_9:"poort10",RGB_LINEFOLLOW_INIT_PORT_10:"port11",RGB_LINEFOLLOW_INIT_PORT_11:"port12",rgb_linefollow_init:"initialiseren RGB lijnvolger [SENSOR_ID] : op [PORT]",rgb_linefollow_turning_sens:"RGB lijnvolger[SENSOR_ID] : (default lijnvolgend) zet draai gevoeligheid op [SENS]",rgb_linefollow_speed_diff:"RGB-lijnvolger[SENSOR_ID]: (standaardregel volgende) motor differenti\xEBle snelheid",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"RGB-lijnvolger [SENSOR_ID]: de status van de sonde zoals (RGB4 ~ RGB1) [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB-lijnvolger [SENSOR_ID]: sonde[CHANNEL] detecteert achtergrondkleur?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"rood",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"groen",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"blauw",rgb_linefollow_set_color:"RGB-lijnvolger [SENSOR_ID]: zet doelkleur en invullicht op [COLOR]",rgb_linefollow_get_data:"RGB lijnvolger [SENSOR_ID] : sonde[CHANNEL] waarde",rgb_linefollow_sensor:"RGB Lijnvolger"},it:{rgb_linefollower_rj25:"Inseguitore di linea RGB",extensionName:"Inseguitore di linea RGB",extensionDescription:"Inseguitore di linea RGB",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"port1",RGB_LINEFOLLOW_INIT_PORT_1:"port2",RGB_LINEFOLLOW_INIT_PORT_2:"port3",RGB_LINEFOLLOW_INIT_PORT_3:"port4",RGB_LINEFOLLOW_INIT_PORT_4:"porta5",RGB_LINEFOLLOW_INIT_PORT_5:"port6",RGB_LINEFOLLOW_INIT_PORT_6:"port7",RGB_LINEFOLLOW_INIT_PORT_7:"port8",RGB_LINEFOLLOW_INIT_PORT_8:"port9",RGB_LINEFOLLOW_INIT_PORT_9:"port10",RGB_LINEFOLLOW_INIT_PORT_10:"porta11",RGB_LINEFOLLOW_INIT_PORT_11:"porta12",rgb_linefollow_init:"inizializzare linea follower RGB [SENSOR_ID] : a [PORT]",rgb_linefollow_turning_sens:"RGB Inseguitore di linea [SENSOR_ID] : (segui linea predefinita) impostare la sensibilit\xE0 di svolta [SENS]",rgb_linefollow_speed_diff:"RGB Inseguitore di linea[SENSOR_ID]: (segui linea predefinita) velocit\xE0 differenziale motore",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101 a",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110 a",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111 a",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"RGB Inseguitore di linea[SENSOR_ID]: stato sonda come (RGB4 ~ RGB1) [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB Inseguitore di linea [SENSOR_ID]: sonda[CHANNEL] rileva il colore di sfondo?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"rosso",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"green",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"blu",rgb_linefollow_set_color:"RGB Inseguitore di linea [SENSOR_ID]: impostare il colore di destinazione e la luce di riempimento [COLOR]",rgb_linefollow_get_data:"RGB Inseguitore di linea [SENSOR_ID]: sonda[CHANNEL] restituisci valore",rgb_linefollow_sensor:"Inseguitore di linea RGB"},hr:{rgb_linefollower_rj25:"RGB sledbenik crte",extensionName:"RGB Line Follower",extensionDescription:"RGB Line Follower",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"port1",RGB_LINEFOLLOW_INIT_PORT_1:"port2",RGB_LINEFOLLOW_INIT_PORT_2:"port3",RGB_LINEFOLLOW_INIT_PORT_3:"port4",RGB_LINEFOLLOW_INIT_PORT_4:"port5",RGB_LINEFOLLOW_INIT_PORT_5:"port6",RGB_LINEFOLLOW_INIT_PORT_6:"port7",RGB_LINEFOLLOW_INIT_PORT_7:"port8",RGB_LINEFOLLOW_INIT_PORT_8:"port9",RGB_LINEFOLLOW_INIT_PORT_9:"port10",RGB_LINEFOLLOW_INIT_PORT_10:"port11",RGB_LINEFOLLOW_INIT_PORT_11:"port12",rgb_linefollow_init:"Inicijalizacija RGB sljednika crte [SENSOR_ID] : na [PORT]",rgb_linefollow_turning_sens:"Pratitelj RGB crte[SENSOR_ID] : (zadani redak nakon) postavlja osjetljivost na [SENS]",rgb_linefollow_speed_diff:"Pratitelj RGB crte[SENSOR_ID]: (zadana linija nakon) brzina motornog diferencijala",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"Pratitelj RGB crte [SENSOR_ID]: status sonde kao (RGB4 ~ RGB1) [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB line follower [SENSOR_ID]: sonda[CHANNEL] otkrije boju pozadine?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"crveno",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"zeleno",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"plavo",rgb_linefollow_set_color:"RGB line follower [SENSOR_ID]: postavite ciljanu boju i ispunite svjetlo [COLOR]",rgb_linefollow_get_data:"RGB line follower [SENSOR_ID] : sonda[CHANNEL] vra\u0107eno vrijednost",rgb_linefollow_sensor:"RGB Line Follower"},ru:{rgb_linefollower_rj25:"RGB Line Follower",extensionName:"RGB Line Follower",extensionDescription:"RGB Line Follower",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"\u043F\u043E\u0440\u04421",RGB_LINEFOLLOW_INIT_PORT_1:"\u043F\u043E\u0440\u04422",RGB_LINEFOLLOW_INIT_PORT_2:"\u043F\u043E\u0440\u04423",RGB_LINEFOLLOW_INIT_PORT_3:"\u043F\u043E\u0440\u04424",RGB_LINEFOLLOW_INIT_PORT_4:"\u043F\u043E\u0440\u04425",RGB_LINEFOLLOW_INIT_PORT_5:"\u043F\u043E\u0440\u04426",RGB_LINEFOLLOW_INIT_PORT_6:"\u043F\u043E\u0440\u04427",RGB_LINEFOLLOW_INIT_PORT_7:"\u043F\u043E\u0440\u04428",RGB_LINEFOLLOW_INIT_PORT_8:"\u043F\u043E\u0440\u04429",RGB_LINEFOLLOW_INIT_PORT_9:"\u043F\u043E\u0440\u044210",RGB_LINEFOLLOW_INIT_PORT_10:"\u043F\u043E\u0440\u044211",RGB_LINEFOLLOW_INIT_PORT_11:"\u043F\u043E\u0440\u044212",rgb_linefollow_init:"\u0438\u043D\u0438\u0446\u0438\u0430\u043B\u0438\u0437\u0430\u0446\u0438\u044F \u043B\u0438\u043D\u0438\u0438 RGB line follower [SENSOR_ID] : \u0432 [PORT]",rgb_linefollow_turning_sens:"RGB line follower[SENSOR_ID] : (\u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430) \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u0435 \u0447\u0443\u0432\u0441\u0442\u0432\u0438\u0442\u0435\u043B\u044C\u043D\u043E\u0441\u0442\u044C \u043F\u043E\u0432\u043E\u0440\u043E\u0442\u0430 \u043A [SENS]",rgb_linefollow_speed_diff:"RGB \u043B\u0438\u043D\u0438\u044F \u043F\u043E\u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u0435\u043B\u0435\u043C[SENSOR_ID]: (\u043F\u043E \u0443\u043C\u043E\u043B\u0447\u0430\u043D\u0438\u044E \u0441\u043B\u0435\u0434\u0443\u044E\u0449\u0430\u044F \u0441\u0442\u0440\u043E\u043A\u0430) \u0434\u0438\u0444\u0444\u0435\u0440\u0435\u043D\u0446\u0438\u0430\u043B\u044C\u043D\u044B\u0439 \u0441\u043A\u043E\u0440\u043E\u0441\u0442\u044C \u0434\u0432\u0438\u0433\u0430\u0442\u0435\u043B\u044F",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"RGB \u043B\u0438\u043D\u0438\u044F \u043F\u043E\u0441\u043B\u0435\u0434\u043E\u0432\u0430\u0442\u0435\u043B\u0435\u043C [SENSOR_ID]: \u0421\u043E\u0441\u0442\u043E\u044F\u043D\u0438\u0435 \u0437\u043E\u043D\u0434\u0430 \u043A\u0430\u043A (RGB4 ~ RGB1) [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB line follower [SENSOR_ID]: \u0437\u043E\u043D\u0434[CHANNEL] \u043E\u0431\u043D\u0430\u0440\u0443\u0436\u0438\u0432\u0430\u0435\u0442 \u0446\u0432\u0435\u0442 \u0444\u043E\u043D\u0430?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"\u043A\u0440\u0430\u0441\u043D\u044B\u0439",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"\u0437\u0435\u043B\u0451\u043D\u044B\u0439",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"\u0441\u0438\u043D\u0438\u0439",rgb_linefollow_set_color:"RGB line follower [SENSOR_ID]: \u0443\u0441\u0442\u0430\u043D\u043E\u0432\u0438\u0442\u044C \u0446\u0435\u043B\u0435\u0432\u043E\u0439 \u0446\u0432\u0435\u0442 \u0438 \u0437\u0430\u043F\u043E\u043B\u043D\u0438\u0442\u044C \u0441\u0432\u0435\u0442 [COLOR]",rgb_linefollow_get_data:"RGB line follower [SENSOR_ID] : \u0437\u043E\u043D\u0434[CHANNEL] \u0412\u043E\u0437\u0432\u0440\u0430\u0449\u0430\u0435\u043C\u043E\u0435 \u0437\u043D\u0430\u0447\u0435\u043D\u0438\u0435",rgb_linefollow_sensor:"RGB Line Follower"},pt:{rgb_linefollower_rj25:"RGB Line Follower",extensionName:"RGB Line Follower",extensionDescription:"RGB Line Follower",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"port1",RGB_LINEFOLLOW_INIT_PORT_1:"port2",RGB_LINEFOLLOW_INIT_PORT_2:"port3",RGB_LINEFOLLOW_INIT_PORT_3:"port4",RGB_LINEFOLLOW_INIT_PORT_4:"port5",RGB_LINEFOLLOW_INIT_PORT_5:"port6",RGB_LINEFOLLOW_INIT_PORT_6:"port7",RGB_LINEFOLLOW_INIT_PORT_7:"port8",RGB_LINEFOLLOW_INIT_PORT_8:"port9",RGB_LINEFOLLOW_INIT_PORT_9:"port10",RGB_LINEFOLLOW_INIT_PORT_10:"port11",RGB_LINEFOLLOW_INIT_PORT_11:"port12",rgb_linefollow_init:"inicializar o RGB line follower [SENSOR_ID] : em [PORT]",rgb_linefollow_turning_sens:"RGB line follower[SENSOR_ID] : (a linha padr\xE3o seguinte) ajustou a sensibilidade de giro a [SENS]",rgb_linefollow_speed_diff:"Linha de seguidor RGB[SENSOR_ID]: (linha padr\xE3o seguinte) velocidade diferencial do motor",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"Linha de seguidor RGB [SENSOR_ID]: estado da sonda como (RGB4 ~ RGB1) [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB line follower [SENSOR_ID]: sonda[CHANNEL] detecta a cor de fundo?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"vermelho",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"verde",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"azul",rgb_linefollow_set_color:"RGB line follower [SENSOR_ID]: definir a cor-alvo e preencher a luz [COLOR]",rgb_linefollow_get_data:"RGB line follower [SENSOR_ID] : sonda[CHANNEL] valor de retorno",rgb_linefollow_sensor:"RGB Line Follower"},fi:{rgb_linefollower_rj25:"RGB Line Follower",extensionName:"RGB Line Follower",extensionDescription:"RGB Line Follower",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"port1",RGB_LINEFOLLOW_INIT_PORT_1:"port2",RGB_LINEFOLLOW_INIT_PORT_2:"port3",RGB_LINEFOLLOW_INIT_PORT_3:"port4",RGB_LINEFOLLOW_INIT_PORT_4:"port5",RGB_LINEFOLLOW_INIT_PORT_5:"port6",RGB_LINEFOLLOW_INIT_PORT_6:"port7",RGB_LINEFOLLOW_INIT_PORT_7:"port8",RGB_LINEFOLLOW_INIT_PORT_8:"port9",RGB_LINEFOLLOW_INIT_PORT_9:"port10",RGB_LINEFOLLOW_INIT_PORT_10:"port11",RGB_LINEFOLLOW_INIT_PORT_11:"port12",rgb_linefollow_init:"alusta RGB line follower [SENSOR_ID] : at [PORT]",rgb_linefollow_turning_sens:"RGB line follower[SENSOR_ID] : (oletus viiva seuraava) asettaa k\xE4\xE4nt\xF6 herkkyyden [SENS]",rgb_linefollow_speed_diff:"RGB-viivan seuraaja[SENSOR_ID]: (oletus viiva seuraava) moottorin differentiaali nopeus",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"RGB-viivan seuraaja [SENSOR_ID]: anturin tila (RGB4 ~ RGB1) [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB line follower [SENSOR_ID]: anturi[CHANNEL] havaitsee tausta v\xE4rin?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"punainen",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"vihre\xE4",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"sininen",rgb_linefollow_set_color:"RGB line follower[SENSOR_ID]: Aseta kohde v\xE4ri ja t\xE4ytt\xF6 valo [COLOR]",rgb_linefollow_get_data:"RGB line follower [SENSOR_ID] : anturi[CHANNEL] Paluu arvo",rgb_linefollow_sensor:"RGB Line Follower"},tr:{rgb_linefollower_rj25:"RGB \xC7izgi \u0130zleyici",extensionName:"RGB \xC7izgi \u0130zleyici",extensionDescription:"RGB \xC7izgi \u0130zleyici",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"giri\u015F1",RGB_LINEFOLLOW_INIT_PORT_1:"giri\u015F2",RGB_LINEFOLLOW_INIT_PORT_2:"giri\u015F3",RGB_LINEFOLLOW_INIT_PORT_3:"giri\u015F4",RGB_LINEFOLLOW_INIT_PORT_4:"giri\u015F5",RGB_LINEFOLLOW_INIT_PORT_5:"giri\u015F6",RGB_LINEFOLLOW_INIT_PORT_6:"giri\u015F7",RGB_LINEFOLLOW_INIT_PORT_7:"giri\u015F8",RGB_LINEFOLLOW_INIT_PORT_8:"giri\u015F9",RGB_LINEFOLLOW_INIT_PORT_9:"giri\u015F10",RGB_LINEFOLLOW_INIT_PORT_10:"giri\u015F11",RGB_LINEFOLLOW_INIT_PORT_11:"giri\u015F12",rgb_linefollow_init:"RGB line follower ba\u015Flatma [SENSOR_ID] : at [PORT]",rgb_linefollow_turning_sens:"RGB line follower[SENSOR_ID] : (varsay\u0131lan sat\u0131r takip) tornalama duyarl\u0131l\u0131\u011F\u0131 [SENS]",rgb_linefollow_speed_diff:"RGB \xE7izgi takip\xE7isi[SENSOR_ID]: (varsay\u0131lan sat\u0131r takip) motor diferansiyel h\u0131z\u0131",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"RGB \xE7izgi takip\xE7isi [SENSOR_ID]: prob durumu (RGB4 ~ RGB1) [SENSOR_STATUS]",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"RGB line follower[SENSOR_ID]: prob[CHANNEL] arka plan rengini alg\u0131lar?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"k\u0131rm\u0131z\u0131",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"ye\u015Fil",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"mavi",rgb_linefollow_set_color:"RGB line follower [SENSOR_ID]: hedef rengi ve dolgu \u0131\u015F\u0131\u011F\u0131n\u0131 [COLOR]",rgb_linefollow_get_data:"RGB line follower [SENSOR_ID] : prob[CHANNEL] d\xF6n\xFC\u015F de\u011Feri",rgb_linefollow_sensor:"RGB \xC7izgi \u0130zleyici"},tk:{rgb_linefollower_rj25:"RGB \xC7yzygy Yzarla\xFDjy",extensionName:"RGB \xC7yzygy Yzarla\xFDjy",extensionDescription:"RGB \xC7yzygy Yzarla\xFDjy",RGB_LINEFOLLOW_INIT_SENSOR_ID_0:"1",RGB_LINEFOLLOW_INIT_SENSOR_ID_1:"2",RGB_LINEFOLLOW_INIT_SENSOR_ID_2:"3",RGB_LINEFOLLOW_INIT_SENSOR_ID_3:"4",RGB_LINEFOLLOW_INIT_PORT_0:"port1",RGB_LINEFOLLOW_INIT_PORT_1:"port2",RGB_LINEFOLLOW_INIT_PORT_2:"port3",RGB_LINEFOLLOW_INIT_PORT_3:"port4",RGB_LINEFOLLOW_INIT_PORT_4:"port5",RGB_LINEFOLLOW_INIT_PORT_5:"port6",RGB_LINEFOLLOW_INIT_PORT_6:"port7",RGB_LINEFOLLOW_INIT_PORT_7:"port8",RGB_LINEFOLLOW_INIT_PORT_8:"port9",RGB_LINEFOLLOW_INIT_PORT_9:"port10",RGB_LINEFOLLOW_INIT_PORT_10:"port11",RGB_LINEFOLLOW_INIT_PORT_11:"port12",rgb_linefollow_init:"[PORT] portundaky [SENSOR_ID] RGB \xC7yzygy Yzarla\xFDjyny i\u015Flet",rgb_linefollow_turning_sens:"[SENSOR_ID] RGB \xE7yzyk yzarla\xFDjysy: (kabul edil\xFD\xE4n \xE7yzyk yzarla\xFDjyny\u0148) \xF6wr\xFCli\u015F du\xFDgurlygyny [SENS] derejesine \xFC\xFDtget",rgb_linefollow_speed_diff:"[SENSOR_ID] RGB \xE7yzyk yzarla\xFDjysy: (kabul edil\xFD\xE4n \xE7yzyk yzarla\xFDjyny\u0148) hereketlendirijisini\u0148 differensial tizligi",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0:"0000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1:"0001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2:"0010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3:"0011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4:"0100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5:"0101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6:"0110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7:"0111",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8:"1000",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9:"1001",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10:"1010",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11:"1011",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12:"1100",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13:"1101",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14:"1110",RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15:"1111",rgb_linefollow_sensor_status:"[SENSOR_ID] RGB \xC7yzyk yzarla\xFDjy du\xFDujy enjam: probasyny\u0148 \xFDagda\xFDyny\uFF08RGB4~RGB1\uFF09[SENSOR_STATUS] edip belle",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0:"RGB1",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1:"RGB2",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2:"RGB3",RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3:"RGB4",rgb_linefollow_background_detect:"[SENSOR_ID] RGB \xC7yzyk yzarla\xFDjy du\xFDujy enjam: [CHANNEL] probasy arakadaky re\u0148ki du\xFD\xFDarmy?",RGB_LINEFOLLOW_SET_COLOR_COLOR_0:"gyzyl",RGB_LINEFOLLOW_SET_COLOR_COLOR_1:"\xFDa\u015Fyl",RGB_LINEFOLLOW_SET_COLOR_COLOR_2:"g\xF6k",rgb_linefollow_set_color:"[SENSOR_ID] RGB \xC7yzyk yzarla\xFDjy du\xFDujy enjam: maksat edinil\xFD\xE4n we dolduryl\xFDan re\u0148ki [COLOR] edip belle",rgb_linefollow_get_data:"[SENSOR_ID] RGB \xC7yzyk yzarla\xFDjy du\xFDujy enjam: [CHANNEL] probasyny\u0148 ga\xFDt\xFDan bahasy",rgb_linefollow_sensor:"RGB \xC7yzygy Yzarla\xFDjy"}},B={arduinoc:{}},s={arduino:[{filename:"src/MeRGBLineFollower.cpp",code:"/**\n * par Copyright (C), 2012-2016, MakeBlock\n * class   MeRGBLineFollower\n * \brief   Driver for MeRGBLineFollower module.\n * @file    MeRGBLineFollower.cpp\n * @author  MakeBlock\n * @version V1.0.0\n * @date    2017/09/26\n * @brief   Driver for MeRGBLineFollower module.\n *\n * par Copyright\n * This software is Copyright (C), 2012-2016, MakeBlock. Use is subject to license \n\n * conditions. The main licensing options available are GPL V2 or Commercial: \n\n *\n * par Open Source Licensing GPL V2\n * This is the appropriate option if you want to share the source code of your \n\n * application with everyone you distribute it to, and you also want to give them \n\n * the right to share who uses it. If you wish to use this software under Open \n\n * Source Licensing, you must contribute all your source code to the open source \n\n * community in accordance with the GPL Version 2 when your application is \n\n * distributed. See http://www.gnu.org/copyleft/gpl.html\n *\n * par Description\n * This file is a drive for MeRGBLineFollower module, It supports MeRGBLineFollower V1.0 device provided\n * by MakeBlock.\n *\n * par Method List:\n *\n *    1.void MeRGBLineFollower::setpin(uint8_t AD0, uint8_t INT)\n *\t \t2.void MeRGBLineFollower::begin(void)\n *    3.uint8_t MeRGBLineFollower::getDevAddr(void)\n *    4.uint8_t MeRGBLineFollower::getADCValueRGB1(void)\n *    5.uint8_t MeRGBLineFollower::getADCValueRGB2(void)\n *    6.uint8_t MeRGBLineFollower::getADCValueRGB3(void)\n *    7.uint8_t MeRGBLineFollower::getADCValueRGB4(void)\n *    8.void MeRGBLineFollower::setKp(float value)\n *    9.int16_t MeRGBLineFollower::getPositionOffset(void)\n *    10.uint8_t MeRGBLineFollower::getPositionState(void)\n *    11.uint8_t MeRGBLineFollower::getIicErrorCnt(void)\n *    12.uint8_t MeRGBLineFollower::getStudyTypes(void)\n *    13.void MeRGBLineFollower::updataAllSensorValue(void)\n *    14.int8_t MeRGBLineFollower::readData(uint8_t start, uint8_t *buffer, uint8_t size)\n *    15.int8_t MeRGBLineFollower::writeReg(uint8_t reg, uint8_t data)\n *    16.int8_t MeRGBLineFollower::writeData(uint8_t start, const uint8_t *pData, uint8_t size)\n *\n * par History:\n * <pre>\n * \"<Author>\"         \"<Time>\"        \"<Version>\"        \"<Descr>\"\n *  Payton            2017/09/26        1.0.0         rebuild the old lib.\n *  Payton            2018/07/31        1.0.1         deletel #include <Wire.h> and #include <SoftwareSerial.h>\n * </pre>\n *\n * @example MeRGBLineFollowerTest.ino\n */\n\n/* Includes ------------------------------------------------------------------*/\n#include \"MeRGBLineFollower.h\"\n\n#include <Arduino.h>\n\n/* Private functions ---------------------------------------------------------*/\n#ifdef ME_PORT_DEFINED\n/**\n * Alternate Constructor which can call your own function to map the MeRGBLineFollower to arduino port,\n * no pins are used or initialized here\n */\nMeRGBLineFollower::MeRGBLineFollower(void) : MePort(0)\n{\n  Device_Address = RGBLINEFOLLOWER_DEFAULT_ADDRESS;\n}\n\n/**\n * Alternate Constructor which can call your own function to map the MeRGBLineFollower to arduino port,\n * no pins are used or initialized here, but PWM frequency set to 976 Hz\n * param[in]\n *   port - RJ25 port from PORT_1 to M2\n */\nMeRGBLineFollower::MeRGBLineFollower(uint8_t port) : MePort(port)\n{\n  Device_Address = RGBLINEFOLLOWER_DEFAULT_ADDRESS;\n}\n\n/**\n * Alternate Constructor which can call your own function to map the MeRGBLineFollower to arduino port\n * and change the i2c device address\n * no pins are used or initialized here, but PWM frequency set to 976 Hz\n * param[in]\n *   port - RJ25 port from PORT_1 to M2\n * param[in]\n *   address - the i2c address you want to set(0~3), If it's another value,it will be set to 0\n */\nMeRGBLineFollower::MeRGBLineFollower(uint8_t port, uint8_t address) : MePort(port)\n{\n  //address0-11, address1-10, address2-01, address3-00\n  pinMode(s1, OUTPUT);\n  pinMode(s2, OUTPUT);\n  if(address == ADDRESS1)\n  {\n    digitalWrite(s1,HIGH);\n    digitalWrite(s2,HIGH);\n  }\n  else if(address == ADDRESS2)\n  {\n    digitalWrite(s1,LOW);\n    digitalWrite(s2,HIGH);\n  }\n  else if(address == ADDRESS3)\n  {\n    digitalWrite(s1,HIGH);\n    digitalWrite(s2,LOW);\n  }\n  else if(address == ADDRESS4)\n  {\n    digitalWrite(s1,LOW);\n    digitalWrite(s2,LOW);\n  }\n  else\n  { \n    digitalWrite(s1,HIGH);\n    digitalWrite(s2,HIGH);\n    address = ADDRESS1;\n  }\n\n  Device_Address = RGBLINEFOLLOWER_DEFAULT_ADDRESS + address;\n}\n#else  // ME_PORT_DEFINED\n/**\n * Alternate Constructor which can call your own function to map the AD0 and INT to arduino port,\n * no pins are used or initialized here\n * param[in]\n *   AD0 - arduino gpio number\n * param[in]\n *   INT - arduino gpio number\n  * param[in]\n *   address - the i2c address you want to set(0~3), If it's another value,it will be set to 0\n */\nMeRGBLineFollower::MeRGBLineFollower(uint8_t AD0, uint8_t INT, uint8_t address)\n{\n  pinMode(AD0,OUTPUT);\n  pinMode(INT,OUTPUT);\n\n  //address0-11, address1-10, address2-01, address3-00\n  if(address == ADDRESS1)\n  {\n    digitalWrite(AD0,HIGH);\n    digitalWrite(INT,HIGH);\n  }\n  else if(address == ADDRESS2)\n  {\n    digitalWrite(AD0,LOW);\n    digitalWrite(INT,HIGH);\n  }\n  else if(address == ADDRESS3)\n  {\n    digitalWrite(AD0,HIGH);\n    digitalWrite(INT,LOW);\n  }\n  else if(address == ADDRESS4)\n  {\n    digitalWrite(AD0,LOW);\n    digitalWrite(INT,LOW);\n  }\n  else\n  { \n    digitalWrite(AD0,HIGH);\n    digitalWrite(INT,HIGH);\n    address = ADDRESS1;\n  }\n\n  Device_Address = RGBLINEFOLLOWER_DEFAULT_ADDRESS + address;\n}\n\n#endif // ME_PORT_DEFINED\n\n/**\n * par Function\n *   setpin\n * par Description\n *   Set the PIN of the button module.\n * param[in]\n *   AD0 - pin mapping for arduino\n * param[in]\n *   INT - pin mapping for arduino\n * par Output\n *   None\n * \return\n *   None.\n * par Others\n *   Set global variable AD0, INT, s1 and s2\n */\nvoid MeRGBLineFollower::setpin(uint8_t AD0, uint8_t INT)\n{\n  pinMode(AD0,OUTPUT);\n  pinMode(INT,OUTPUT);\n\n#ifdef ME_PORT_DEFINED\n  s1 = AD0;\n  s2 = INT;\n#endif // ME_PORT_DEFINED\n}\n\n/**\n * par Function\n *   begin\n * par Description\n *   Initialize the MeRGBLineFollower.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   None\n * par Others\n *   \n */\nvoid MeRGBLineFollower::begin(void)\n{\n  uint8_t i;\n  \n  Kp = 0.3;\n  study_types = STUDY_IDLE;\n  iic_error_count = 0;\n  \n  Wire.begin();\n  delay(10);\n}\n\n/**\n * par Function\n *   getDevAddr\n * par Description\n *   Get the device address of MeRGBLineFollower.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   The device address of MeRGBLineFollower\n * par Others\n *   None\n */\nuint8_t MeRGBLineFollower::getDevAddr(void)\n{\n  return Device_Address;\n}\n\n/**\n * par Function\n *   getADCValueRGB1\n * par Description\n *   Get the RGB1 sensor ADC value.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   The ADC value of RGB1\n * par Others\n *   \n */\nuint8_t MeRGBLineFollower::getADCValueRGB1(void)\n{\n  return adcOutput[RGB1_INDEX];\n}\n\n/**\n * par Function\n *   getADCValueRGB2\n * par Description\n *   Get the RGB2 sensor ADC value.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   The ADC value of RGB2\n * par Others\n *   \n */\nuint8_t MeRGBLineFollower::getADCValueRGB2(void)\n{\n  return adcOutput[RGB2_INDEX];\n}\n\n/**\n * par Function\n *   getADCValueRGB3\n * par Description\n *   Get the RGB3 sensor ADC value.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   The ADC value of RGB3\n * par Others\n *   \n */\nuint8_t MeRGBLineFollower::getADCValueRGB3(void)\n{\n  return adcOutput[RGB3_INDEX];\n}\n\n/**\n * par Function\n *   getADCValueRGB4\n * par Description\n *   Get the RGB4 sensor ADC value.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   The ADC value of RGB4\n * par Others\n *   \n */\nuint8_t MeRGBLineFollower::getADCValueRGB4(void)\n{\n  return adcOutput[RGB4_INDEX];\n}\n\n/**\n * par Function\n *   setKp\n * par Description\n *   set Kp.\n * param[in]\n *   value: 0 ~ 1\uFF0Cturn sensitivity\n * par Output\n *   None\n * \return\n *   None\n * par Others\n *  \n */\nvoid MeRGBLineFollower::setKp(float value)\n{\n  if((value >= 0) && (value <= 1))\n  {\n    Kp = value;\n  }\n}\n\n/**\n * par Function\n *   getPositionOffset\n * par Description\n *   get turn Value.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   Position offset Value,-512 ~ 512\n      <0,in right\n      >0,in left\n * par Others\n *   |---------------------------|\n     |      |      |      |      |\n     |RGB1  |RGB2  |RGB3  |RGB4  |\n     |      |      |      |      |\n     |---------------------------|\n */\nint16_t MeRGBLineFollower::getPositionOffset(void)\n{\n  return positionOffset;\n}\n\n/**\n * par Function\n *   getPositionState\n * par Description\n *   get turn Value.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   Position StateValue,0x00~0x0F,bit0-RGB1,bit1-RGB2 ,bit2-RGB3  ,bit3-RGB4 \n * par Others\n *   |---------------------------|\n     |      |      |      |      |\n     |RGB1  |RGB2  |RGB3  |RGB4  |\n     |      |      |      |      |\n     |---------------------------|\n */\nuint8_t MeRGBLineFollower::getPositionState(void)\n{\n  return positionState;\n}\n\n/**\n * par Function\n *   getPositionState\n * par Description\n *   get turn Value.\n * param[in]\n *   Speed:set forward speed\n * par Output\n *   None\n * \return\n *   None\n * par Others\n */\n//uint8_t MeRGBLineFollower::getIICErrorCnt(void)\n//{\n//  return iic_error_count;\n//}\n\n/**\n * par Function\n *   getStudyTypes\n * par Description\n *   get turn Value.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   Study types\n*    0. STUDY_IDLE\n*    1. STUDY_BACKGROUND\n*    2. STUDY_TRACK\n * par Others\n */\nuint8_t MeRGBLineFollower::getStudyTypes(void)\n{\n  return study_types;\n}\n\n/**\n * par Function\n *   updataAllSensorValue\n * par Description\n *   updata All Sensor Value.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   \n * par Others\n */\nvoid MeRGBLineFollower::updataAllSensorValue(void)\n{\n  int8_t return_value;\n  int16_t temp_positionOffset;\n  \n  /* read data */\n  return_value = readData(RGBLINEFOLLOWER_DEVICE_ID_ADDR, &i2cData[0], 8);\n  if(return_value == I2C_OK)\n  {\n    if(i2cData[RGBLINEFOLLOWER_DEVICE_ID_ADDR] == RGBLINEFOLLOWER_DEVICE_ID)\n    {\n      adcOutput[RGB1_INDEX] = i2cData[RGBLINEFOLLOWER_RGB1_ADDR];\n      adcOutput[RGB2_INDEX] = i2cData[RGBLINEFOLLOWER_RGB2_ADDR];\n      adcOutput[RGB3_INDEX] = i2cData[RGBLINEFOLLOWER_RGB3_ADDR];\n      adcOutput[RGB4_INDEX] = i2cData[RGBLINEFOLLOWER_RGB4_ADDR];\n      temp_positionOffset = (int16_t)(i2cData[RGBLINEFOLLOWER_TURNOFFSET_L_ADDR] | ((uint16_t)i2cData[RGBLINEFOLLOWER_TURNOFFSET_H_ADDR]<<8));\n      temp_positionOffset = (int16_t)(Kp * temp_positionOffset);\n      positionOffset= constrain(temp_positionOffset, -512, 512);\n      positionState = i2cData[RGBLINEFOLLOWER_STATE_ADDR] & 0x0F;\n      study_types = (i2cData[RGBLINEFOLLOWER_STATE_ADDR]>>4) & 0x03;\n    }\n    else\n    {\n      iic_error_count++;  \n      //Serial.print(\"iic error:\");\n      //Serial.println(iic_error_count);\n    }\n  }\n\n//  Serial.print(\"i2cData[0]:\");\n//  Serial.print(i2cData[0]);\n//  Serial.print(\"  i2cData[1]:\");\n//  Serial.print(i2cData[1]);\n//  Serial.print(\"  i2cData[2]:\");\n//  Serial.print(i2cData[2]);\n//  Serial.print(\"  i2cData[3]:\");\n//  Serial.print(i2cData[3]);\n//  Serial.print(\"  i2cData[4]:\");\n//  Serial.print(i2cData[4]);\n//  Serial.print(\"  i2cData[5]:\");\n//  Serial.print(i2cData[5]);\n//  Serial.print(\"  i2cData[6]:\");\n//  Serial.print(i2cData[6]);\n//  Serial.print(\"  i2cData[7]:\");\n//  Serial.print(i2cData[7]);\n//  Serial.println(\"  \");\n}\n\n/**\n * par Function\n *   studyBackground\n * par Description\n *   study background.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   Return the error code.\n *   the definition of the value of variable return_value:\n *   0:success\n *   1:BUFFER_LENGTH is shorter than size\n *   2:address send, nack received\n *   3:data send, nack received\n *   4:other twi error\n *   refer to the arduino official library twi.c\n * par Others\n */\nint8_t MeRGBLineFollower::studyBackground(void)\n{\n  int8_t return_value = 0;\n  uint8_t data = STUDY_BACKGROUND;\n  return_value = writeReg(RGBLINEFOLLOWER_STUDY_ADDR, data);\n  return(return_value);\n}\n\n/**\n * par Function\n *   studyTrack\n * par Description\n *   study track.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   Return the error code.\n *   the definition of the value of variable return_value:\n *   0:success\n *   1:BUFFER_LENGTH is shorter than size\n *   2:address send, nack received\n *   3:data send, nack received\n *   4:other twi error\n *   refer to the arduino official library twi.c\n * par Others\n */\nint8_t MeRGBLineFollower::studyTrack(void)\n{\n  int8_t return_value = 0;\n  uint8_t data = STUDY_TRACK;\n  return_value = writeReg(RGBLINEFOLLOWER_STUDY_ADDR, data);\n  return(return_value);\n}\n\n/**\n * par Function\n *   setRGBColour\n * par Description\n *   Set the RGB colour.\n * param[in]\n *   types:RGB_COLOUR_RED, RGB_COLOUR_GREEN, RGB_COLOUR_BLUE\n * par Output\n *   None\n * \return\n *   Return the error code.\n *   the definition of the value of variable return_value:\n *   0:success\n *   1:BUFFER_LENGTH is shorter than size\n *   2:address send, nack received\n *   3:data send, nack received\n *   4:other twi error\n *   refer to the arduino official library twi.c\n * par Others\n */\nint8_t MeRGBLineFollower::setRGBColour(uint8_t colour)\n{\n  int8_t return_value = 0;\n  uint8_t data = colour;\n  return_value = writeReg(RGBLINEFOLLOWER_SET_RGB_ADDR, data);\n  return(return_value);\n}\n\n/**\n * par Function\n *   setBackgroundThreshold\n * par Description\n *   set Background Threshold.\n * param[in]\n *   ch:RGB index\n *      0.RGB1_INDEX\n *      1.RGB2_INDEX\n *      2.RGB3_INDEX\n *      3.RGB4_INDEX\n *   threshold:0~255\n * par Output\n *   None\n * \return\n *   Return the error code.\n *   the definition of the value of variable return_value:\n *   0:success\n *   1:BUFFER_LENGTH is shorter than size\n *   2:address send, nack received\n *   3:data send, nack received\n *   4:other twi error\n *   refer to the arduino official library twi.c\n * par Others\n */\nint8_t MeRGBLineFollower::setBackgroundThreshold(uint8_t ch, uint8_t threshold)\n{\n  int8_t return_value = 0;\n  uint8_t data = threshold;\n\n  if(ch > RGB4_INDEX)\n  {\n    return I2C_ERROR;\n  }\n  \n  return_value = writeReg(RGBLINEFOLLOWER_RGB1_BACKGROUND_THRESHOLD_ADDR + ch, data);\n  return(return_value);\n}\n\n/**\n * par Function\n *   setTrackThreshold\n * par Description\n *   set track Threshold.\n * param[in]\n *   ch:RGB index\n *      0.RGB1_INDEX\n *      1.RGB2_INDEX\n *      2.RGB3_INDEX\n *      3.RGB4_INDEX\n *   threshold:0~255\n * par Output\n *   None\n * \return\n *   Return the error code.\n *   the definition of the value of variable return_value:\n *   0:success\n *   1:BUFFER_LENGTH is shorter than size\n *   2:address send, nack received\n *   3:data send, nack received\n *   4:other twi error\n *   refer to the arduino official library twi.c\n * par Others\n */\nint8_t MeRGBLineFollower::setTrackThreshold(uint8_t ch, uint8_t threshold)\n{\n  int8_t return_value = 0;\n  uint8_t data = threshold;\n\n  if(ch > RGB4_INDEX)\n  {\n    return I2C_ERROR;\n  }\n  \n  return_value = writeReg(RGBLINEFOLLOWER_RGB1_TRACK_THRESHOLD_ADDR + ch, data);\n  return(return_value);\n}\n\n/**\n * par Function\n *   getBackgroundThreshold\n * par Description\n *   Get the background threshold .\n * param[in]\n *   ch:RGB index\n *      0.RGB1_INDEX\n *      1.RGB2_INDEX\n *      2.RGB3_INDEX\n *      3.RGB4_INDEX\n * par Output\n *   None\n * \return\n *   Return the background threshold. 0~255\n * par Others\n */\nuint8_t MeRGBLineFollower::getBackgroundThreshold(uint8_t ch)\n{\n  int8_t return_value = 0;\n  uint8_t reg = RGBLINEFOLLOWER_RGB1_BACKGROUND_THRESHOLD_ADDR + ch;\n  \n  if(ch <= RGB4_INDEX)\n  {\n    return_value = readData(reg, &i2cData[reg], 1);\n    delay(50);\n    if(return_value == I2C_OK)\n    {\n      return i2cData[reg];\n    }\n    return i2cData[reg];\n  }\n  \n  return 0;\n}\n\n/**\n * par Function\n *   getTrackThreshold\n * par Description\n *   Get the track threshold .\n * param[in]\n *   ch:RGB index\n *      0.RGB1_INDEX\n *      1.RGB2_INDEX\n *      2.RGB3_INDEX\n *      3.RGB4_INDEX\n * par Output\n *   None\n * \return\n *   Return the track threshold. 0~255\n * par Others\n */\nuint8_t MeRGBLineFollower::getTrackThreshold(uint8_t ch)\n{\n  int8_t return_value = 0;\n  uint8_t reg = RGBLINEFOLLOWER_RGB1_TRACK_THRESHOLD_ADDR + ch;\n  \n  if(ch <= RGB4_INDEX)\n  {\n    return_value = readData(reg, &i2cData[reg], 1);\n    if(return_value == I2C_OK)\n    {\n      return i2cData[reg];\n    }\n    return i2cData[reg];\n  }\n  \n  return 0;\n}\n\n/**\n * par Function\n *   getFirmwareVersion\n * par Description\n *   Get Firmware Version.\n * param[in]\n *   None\n * par Output\n *   buffer: for storage version, length greater than 8\n * \return\n *   None\n * par Others\n */\nvoid MeRGBLineFollower::getFirmwareVersion(char *buffer)\n{\n  int8_t return_value = 0;\n  uint8_t reg = RGBLINEFOLLOWER_GET_VERSION_ADDR;\n\n  return_value = readData(reg, &i2cData[reg], 8);\n  if(return_value == I2C_OK)\n  {\n    memcpy(buffer, &i2cData[reg], 8);\n  }\n  memcpy(buffer, &i2cData[reg], 8);\n}\n\n/**\n * par Function\n *   writeReg\n * par Description\n *   Write the registor of i2c device.\n * param[in]\n *   reg - the address of registor.\n * param[in]\n *   data - the data that will be written to the registor.\n * par Output\n *   None\n * \return\n *   Return the error code.\n *   the definition of the value of variable return_value:\n *   0:success\n *   1:BUFFER_LENGTH is shorter than size\n *   2:address send, nack received\n *   3:data send, nack received\n *   4:other twi error\n *   refer to the arduino official library twi.c\n * par Others\n *   To set the registor for initializing.\n */\nint8_t MeRGBLineFollower::writeReg(uint8_t reg, uint8_t data)\n{\n  int8_t return_value = 0;\n  return_value = writeData(reg, &data, 1);\n  delay(5);\n  return(return_value);\n}\n\n/**\n * par Function\n *   readData\n * par Description\n *   Write the data to i2c device.\n * param[in]\n *   start - the address which will write the data to.\n * param[in]\n *   pData - the head address of data array.\n * param[in]\n *   size - set the number of data will be written to the devide.\n * par Output\n *   None\n * \return\n *   Return the error code.\n *   the definition of the value of variable return_value:\n *   0:success\n *   1:BUFFER_LENGTH is shorter than size\n *   2:address send, nack received\n *   3:data send, nack received\n *   4:other twi error\n *   refer to the arduino official library twi.c\n * par Others\n *   Calling the official i2c library to read data.\n */\nint8_t MeRGBLineFollower::readData(uint8_t start, uint8_t *buffer, uint8_t size)\n{\n  int16_t i = 0;\n  int8_t return_value = 0;\n\n  Wire.beginTransmission(Device_Address);\n  return_value = Wire.write(start);\n  if(return_value != 1)\n  {\n    return(I2C_ERROR);\n  }\n  return_value = Wire.endTransmission(false);\n  if(return_value != 0)\n  {\n    return(return_value);\n  }\n  delayMicroseconds(1);\n  /* Third parameter is true: relase I2C-bus after data is read. */\n  Wire.requestFrom(Device_Address, size, (uint8_t)true);\n  while(Wire.available() && i < size)\n  {\n    buffer[i++] = Wire.read();\n  }\n  delayMicroseconds(1);\n  if(i != size)\n  {\n    return(I2C_ERROR);\n  }\n  return(0); //return: no error \n}\n\n/**\n * par Function\n *   writeData\n * par Description\n *   Write the data to i2c device.\n * param[in]\n *   start - the address which will write the data to.\n * param[in]\n *   pData - the head address of data array.\n * param[in]\n *   size - set the number of data will be written to the devide.\n * par Output\n *   None\n * \return\n *   Return the error code.\n *   the definition of the value of variable return_value:\n *   0:success\n *   1:BUFFER_LENGTH is shorter than size\n *   2:address send, nack received\n *   3:data send, nack received\n *   4:other twi error\n *   refer to the arduino official library twi.c\n * par Others\n *   Calling the official i2c library to write data.\n */\nint8_t MeRGBLineFollower::writeData(uint8_t start, const uint8_t *pData, uint8_t size)\n{\n  int8_t return_value = 0;\n  Wire.beginTransmission(Device_Address);\n  return_value = Wire.write(start); \n  if(return_value != 1)\n  {\n    return(I2C_ERROR);\n  }\n  Wire.write(pData, size);  \n  return_value = Wire.endTransmission(true); \n  return(return_value); //return: no error                     \n}\n\n/**\n * par Function\n *\t loop\n * par Description\n *\tRGBLineFollower loop.\n * param[in]\n *\t None\n * par Output\n *\t None\n * \return\n *\t \n * par Others\n */\nvoid MeRGBLineFollower::loop(void)\n{\n  if(millis() - updata_time > 8)  \n  {\n    updata_time = millis();\n    updataAllSensorValue();\n  }\n}\n"},{filename:"src/MeRGBLineFollower.h",code:"/**\n * par Copyright (C), 2012-2016, MakeBlock\n * class   MeRGBLineFollower\n * \brief   Driver for MeRGBLineFollower module.\n * @file   MeRGBLineFollower.h\n * @author  MakeBlock\n * @version V1.0.0\n * @date    2017/09/26\n * @brief   Header for MeRGBLineFollower.cpp module.\n *\n * par Copyright\n * This software is Copyright (C), 2012-2016, MakeBlock. Use is subject to license \n\n * conditions. The main licensing options available are GPL V2 or Commercial: \n\n *\n * par Open Source Licensing GPL V2\n * This is the appropriate option if you want to share the source code of your \n\n * application with everyone you distribute it to, and you also want to give them \n\n * the right to share who uses it. If you wish to use this software under Open \n\n * Source Licensing, you must contribute all your source code to the open source \n\n * community in accordance with the GPL Version 2 when your application is \n\n * distributed. See http://www.gnu.org/copyleft/gpl.html\n *\n * par Description\n * This file is a drive for MeRGBLineFollower module, It supports MeRGBLineFollower V1.0 device provided\n * by MakeBlock.\n *\n * par Method List:\n *\n *    1.void MeRGBLineFollower::setpin(uint8_t AD0, uint8_t INT)\n *\t \t2.void MeRGBLineFollower::begin(void)\n *    3.uint8_t MeRGBLineFollower::getDevAddr(void)\n *    4.uint8_t MeRGBLineFollower::getADCValueRGB1(void)\n *    5.uint8_t MeRGBLineFollower::getADCValueRGB2(void)\n *    6.uint8_t MeRGBLineFollower::getADCValueRGB3(void)\n *    7.uint8_t MeRGBLineFollower::getADCValueRGB4(void)\n *    8.void MeRGBLineFollower::setKp(float value)\n *    9.int16_t MeRGBLineFollower::getPositionOffset(void)\n *    10.uint8_t MeRGBLineFollower::getPositionState(void)\n *    11.uint8_t MeRGBLineFollower::getIicErrorCnt(void)\n *    12.uint8_t MeRGBLineFollower::getStudyTypes(void)\n *    13.void MeRGBLineFollower::updataAllSensorValue(void)\n *    14.int8_t MeRGBLineFollower::readData(uint8_t start, uint8_t *buffer, uint8_t size)\n *    15.int8_t MeRGBLineFollower::writeReg(uint8_t reg, uint8_t data)\n *    16.int8_t MeRGBLineFollower::writeData(uint8_t start, const uint8_t *pData, uint8_t size)\n *\n * par History:\n * <pre>\n * \"<Author>\"         \"<Time>\"        \"<Version>\"        \"<Descr>\"\n *  Payton            2017/09/26          1.0.0         rebuild the old lib.\n *  Payton            2018/07/31          1.0.1         deletel #include <Wire.h> and #include <SoftwareSerial.h>\n * </pre>\n *\n */\n\n/* Define to prevent recursive inclusion -------------------------------------*/\n#ifndef MeRGBLineFollower_H\n#define MeRGBLineFollower_H\n\n/* Includes ------------------------------------------------------------------*/\n#include <stdint.h>\n#include <stdbool.h>\n#include <Arduino.h>\n#include \"MeConfig.h\"\n#ifdef ME_PORT_DEFINED\n#include \"MePort.h\"\n#endif // ME_PORT_DEFINED\n\n/* Exported macro ------------------------------------------------------------*/\n#define I2C_ERROR                  \t\t\t\t\t\t(-1)\n#define I2C_OK                    \t\t\t\t\t\t(0)\n#define RGBLINEFOLLOWER_DEFAULT_ADDRESS      (0x20)\n#define RGBLINEFOLLOWER_DEVICE_ID\t\t\t\t\t\t\t(0xFA)\n\n//RGBLineFollower IIC Register Address\n#define RGBLINEFOLLOWER_DEVICE_ID_ADDR                  (0x00)\n#define RGBLINEFOLLOWER_RGB1_ADDR                       (0x01)\n#define RGBLINEFOLLOWER_RGB2_ADDR                       (0x02)\n#define RGBLINEFOLLOWER_RGB3_ADDR                       (0x03)\n#define RGBLINEFOLLOWER_RGB4_ADDR                       (0x04)\n#define RGBLINEFOLLOWER_TURNOFFSET_L_ADDR               (0x05)\n#define RGBLINEFOLLOWER_TURNOFFSET_H_ADDR               (0x06)\n#define RGBLINEFOLLOWER_STATE_ADDR       \t              (0x07)\n#define RGBLINEFOLLOWER_RGB1_BACKGROUND_THRESHOLD_ADDR  (0x08)\n#define RGBLINEFOLLOWER_RGB2_BACKGROUND_THRESHOLD_ADDR  (0x09)\n#define RGBLINEFOLLOWER_RGB3_BACKGROUND_THRESHOLD_ADDR  (0x0A)\n#define RGBLINEFOLLOWER_RGB4_BACKGROUND_THRESHOLD_ADDR  (0x0B)\n#define RGBLINEFOLLOWER_RGB1_TRACK_THRESHOLD_ADDR       (0x0C)\n#define RGBLINEFOLLOWER_RGB2_TRACK_THRESHOLD_ADDR       (0x0D)\n#define RGBLINEFOLLOWER_RGB3_TRACK_THRESHOLD_ADDR       (0x0E)\n#define RGBLINEFOLLOWER_RGB4_TRACK_THRESHOLD_ADDR       (0x0F)\n#define RGBLINEFOLLOWER_GET_VERSION_ADDR                (0x10)\n#define RGBLINEFOLLOWER_STUDY_ADDR                      (0x31)\n#define RGBLINEFOLLOWER_SET_RGB_ADDR                    (0x32)\n\n\n//RGBLineFollower index\n#define RGB1_INDEX\t\t0\n#define RGB2_INDEX\t\t1\n#define RGB3_INDEX\t\t2\n#define RGB4_INDEX\t\t3\n\n//RGBLineFollower number\n#define RGBLINEFOLLOWER_NUM\t\t         (0x04)\n\n//address\n#define ADDRESS1\t\t0\n#define ADDRESS2\t\t1\n#define ADDRESS3\t\t2\n#define ADDRESS4\t\t3\n\n//study types\n#define STUDY_IDLE          0\n#define STUDY_BACKGROUND    1\n#define STUDY_TRACK         2\n\n\n//RGB culour\n#define RGB_COLOUR_RED      1\n#define RGB_COLOUR_GREEN    2\n#define RGB_COLOUR_BLUE     3\n\n/**\n * Class: MeRGBLineFollower\n * par Description\n * Declaration of Class MeRGBLineFollower\n */\n#ifndef ME_PORT_DEFINED\nclass MeRGBLineFollower\n#else // !ME_PORT_DEFINED\nclass MeRGBLineFollower : public MePort\n#endif // !ME_PORT_DEFINED\n{\npublic:\n#ifdef ME_PORT_DEFINED\n/**\n * Alternate Constructor which can call your own function to map the MeCompass to arduino port,\n * no pins are used or initialized here\n */\n  MeRGBLineFollower(void);\n\n/**\n * Alternate Constructor which can call your own function to map the MeCompass to arduino port,\n * no pins are used or initialized here, but PWM frequency set to 976 Hz\n * param[in]\n *   port - RJ25 port from PORT_1 to M2\n */\n  MeRGBLineFollower(uint8_t port);\n\n/**\n * Alternate Constructor which can call your own function to map the MeCompass to arduino port\n * and change the i2c device address\n * no pins are used or initialized here, but PWM frequency set to 976 Hz\n * param[in]\n *   port - RJ25 port from PORT_1 to M2\n * param[in]\n *   address - the i2c address you want to set\n */\n  MeRGBLineFollower(uint8_t port, uint8_t address);\n#else\n/**\n * Alternate Constructor which can call your own function to map the AD0 and INT to arduino port,\n * no pins are used or initialized here\n * param[in]\n *   AD0 - arduino gpio number\n * param[in]\n *   INT - arduino gpio number\n  * param[in]\n *   address - the i2c address you want to set(0~3), If it's another value,it will be set to 0\n */\n MeRGBLineFollower(uint8_t AD0, uint8_t INT, uint8_t address);\n\n#endif  //  ME_PORT_DEFINED\n/**\n * par Function\n *   setpin\n * par Description\n *   Set the PIN of the button module.\n * param[in]\n *   AD0 - pin mapping for arduino\n * param[in]\n *   INT - pin mapping for arduino\n * par Output\n *   None\n * \return\n *   None.\n * par Others\n *   Set global variable _AD0, _INT, s1 and s2\n */\n  void setpin(uint8_t AD0, uint8_t INT);\n\n/**\n * par Function\n *   begin\n * par Description\n *   Initialize the MeRGBLineFollower.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   None\n * par Others\n *   None\n */\n  void begin();\n\n/**\n * par Function\n *   getDevAddr\n * par Description\n *   Get the device address of RGBLineFollower.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   The device address of RGBLineFollower\n * par Others\n *   None\n */\n  uint8_t getDevAddr(void);\n\n/**\n * par Function\n *   getADCValueRGB1\n * par Description\n *   Get the RGB1 sensor ADC value.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   The ADC value of RGB1:0~255\n * par Others\n *   \n */\n\tuint8_t getADCValueRGB1(void);\n\n/**\n * par Function\n *   getADCValueRGB2\n * par Description\n *   Get the RGB2 sensor ADC value.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   The ADC value of RGB2:0~255\n * par Others\n *   \n */\n\tuint8_t getADCValueRGB2(void);\n\n/**\n * par Function\n *   getADCValueRGB3\n * par Description\n *   Get the RGB3 sensor ADC value.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   The ADC value of RGB3:0~255\n * par Others\n *   \n */\n\tuint8_t getADCValueRGB3(void);\n\n/**\n * par Function\n *   getADCValueRGB4\n * par Description\n *   Get the RGB4 sensor ADC value.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   The ADC value of RGB4:0~255\n * par Others\n *   \n */\n\tuint8_t getADCValueRGB4(void);\n\n/**\n * par Function\n *   setKp\n * par Description\n *   set Kp.\n * param[in]\n *   value: 0 ~ 1\uFF0Cturn sensitivity\n * par Output\n *   None\n * \return\n *   None\n * par Others\n *  \n */\n\tvoid setKp(float value);\n\n/**\n * par Function\n *   getPositionOffset\n * par Description\n *   get turn Value.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   Position offset Value,-512 ~ 512\n      <0,in right\n      >0,in left\n * par Others\n *   |---------------------------|\n     |      |      |      |      |\n     |RGB1  |RGB2  |RGB3  |RGB4  |\n     |      |      |      |      |\n     |---------------------------|\n */\n\tint16_t getPositionOffset(void);\n\n\n/**\n * par Function\n *   getPositionState\n * par Description\n *   get turn Value.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   Position StateValue,0x00~0x0F,bit0-RGB1,bit1-RGB2 ,bit2-RGB3  ,bit3-RGB4 \n * par Others\n *   |---------------------------|\n     |      |      |      |      |\n     |RGB1  |RGB2  |RGB3  |RGB4  |\n     |      |      |      |      |\n     |---------------------------|\n */\n\tuint8_t getPositionState(void);\n\t\n/**\n   * par Function\n   *   getStudyTypes\n   * par Description\n   *   get turn Value.\n   * param[in]\n   *   None\n   * par Output\n   *   None\n   * \return\n   *   Study types\n  *    0. STUDY_IDLE\n  *    1. STUDY_BACKGROUND\n  *    2. STUDY_TRACK\n   * par Others\n   */\n  uint8_t getStudyTypes(void);\n\n/**\n * par Function\n *   updataAllSensorValue\n * par Description\n *   updata All Sensor Value.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   None\n * par Others\n */\n\tvoid updataAllSensorValue(void);\n\t\n/**\n   * par Function\n   *   studyBackground\n   * par Description\n   *   study background.\n   * param[in]\n   *   None\n   * par Output\n   *   None\n   * \return\n   *   Return the error code.\n   *   the definition of the value of variable return_value:\n   *   0:success\n   *   1:BUFFER_LENGTH is shorter than size\n   *   2:address send, nack received\n   *   3:data send, nack received\n   *   4:other twi error\n   *   refer to the arduino official library twi.c\n   * par Others\n   */\n  int8_t studyBackground(void);\n\n/**\n * par Function\n *   studyTrack\n * par Description\n *   study track.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   Return the error code.\n *   the definition of the value of variable return_value:\n *   0:success\n *   1:BUFFER_LENGTH is shorter than size\n *   2:address send, nack received\n *   3:data send, nack received\n *   4:other twi error\n *   refer to the arduino official library twi.c\n * par Others\n */\n  int8_t studyTrack(void);\n  \n/**\n * par Function\n *   getThreshold\n * par Description\n *   Get the threshold between background and track.\n * param[in]\n *   None\n * par Output\n *   None\n * \return\n *   Return the threshold. 0~255\n * par Others\n */\nint8_t getThreshold(void);\n\n/**\n * par Function\n *   setRGBColour\n * par Description\n *   Set the RGB colour.\n * param[in]\n *   types:RGB_COLOUR_RED, RGB_COLOUR_GREEN, RGB_COLOUR_BLUE\n * par Output\n *   None\n * \return\n *   Return the error code.\n *   the definition of the value of variable return_value:\n *   0:success\n *   1:BUFFER_LENGTH is shorter than size\n *   2:address send, nack received\n *   3:data send, nack received\n *   4:other twi error\n *   refer to the arduino official library twi.c\n * par Others\n */\n int8_t setRGBColour(uint8_t colour);\n\n /**\n  * par Function\n  *   setBackgroundThreshold\n  * par Description\n  *   set Background Threshold.\n  * param[in]\n  *   ch:RGB index\n  *      0.RGB1_INDEX\n  *      1.RGB2_INDEX\n  *      2.RGB3_INDEX\n  *      3.RGB4_INDEX\n  *   threshold:0~255\n  * par Output\n  *   None\n  * \return\n  *   Return the error code.\n  *   the definition of the value of variable return_value:\n  *   0:success\n  *   1:BUFFER_LENGTH is shorter than size\n  *   2:address send, nack received\n  *   3:data send, nack received\n  *   4:other twi error\n  *   refer to the arduino official library twi.c\n  * par Others\n  */\n int8_t setBackgroundThreshold(uint8_t ch, uint8_t threshold);\n \n /**\n  * par Function\n  *   setTrackThreshold\n  * par Description\n  *   set track Threshold.\n  * param[in]\n  *   ch:RGB index\n  *      0.RGB1_INDEX\n  *      1.RGB2_INDEX\n  *      2.RGB3_INDEX\n  *      3.RGB4_INDEX\n  *   threshold:0~255\n  * par Output\n  *   None\n  * \return\n  *   Return the error code.\n  *   the definition of the value of variable return_value:\n  *   0:success\n  *   1:BUFFER_LENGTH is shorter than size\n  *   2:address send, nack received\n  *   3:data send, nack received\n  *   4:other twi error\n  *   refer to the arduino official library twi.c\n  * par Others\n  */\n int8_t setTrackThreshold(uint8_t ch, uint8_t threshold);\n\n/**\n  * par Function\n  *   getBackgroundThreshold\n  * par Description\n  *   Get the background threshold .\n  * param[in]\n  *   ch:RGB index\n  *      0.RGB1_INDEX\n  *      1.RGB2_INDEX\n  *      2.RGB3_INDEX\n  *      3.RGB4_INDEX\n  * par Output\n  *   None\n  * \return\n  *   Return the background threshold. 0~255\n  * par Others\n  */\n uint8_t getBackgroundThreshold(uint8_t ch);\n \n/**\n * par Function\n *   getTrackThreshold\n * par Description\n *   Get the track threshold .\n * param[in]\n *   ch:RGB index\n *      0.RGB1_INDEX\n *      1.RGB2_INDEX\n *      2.RGB3_INDEX\n *      3.RGB4_INDEX\n * par Output\n *   None\n * \return\n *   Return the track threshold. 0~255\n * par Others\n */\nuint8_t getTrackThreshold(uint8_t ch);\n\n/**\n * par Function\n *   getFirmwareVersion\n * par Description\n *   Get Firmware Version.\n * param[in]\n *   None\n * par Output\n *   buffer: for storage version, length greater than 8\n * \return\n *   None\n * par Others\n */\nvoid getFirmwareVersion(char *buffer);\n\n/**\n\t * par Function\n\t *\t loop\n\t * par Description\n\t *\tRGBLineFollower loop.\n\t * param[in]\n\t *\t None\n\t * par Output\n\t *\t None\n\t * \return\n\t *\t \n\t * par Others\n\t */\n  void loop(void);\n\nprivate:\n  uint8_t i2cData[25];\n  uint8_t adcOutput[RGBLINEFOLLOWER_NUM];\n  uint8_t Device_Address;\n  float Kp;\n  int16_t positionOffset;\n  uint8_t positionState;\n  uint8_t study_types;\n  uint32_t iic_error_count;\n  unsigned long updata_time;\n  \n/**\n * par Function\n *   writeReg\n * par Description\n *   Write the registor of i2c device.\n * param[in]\n *   reg - the address of registor.\n * param[in]\n *   data - the data that will be written to the registor.\n * par Output\n *   None\n * \return\n *   Return the error code.\n *   the definition of the value of variable return_value:\n *   0:success\n *   1:BUFFER_LENGTH is shorter than size\n *   2:address send, nack received\n *   3:data send, nack received\n *   4:other twi error\n *   refer to the arduino official library twi.c\n * par Others\n *   To set the registor for initializing.\n */\n  int8_t writeReg(uint8_t reg, uint8_t data);\n\n/**\n * par Function\n *   readData\n * par Description\n *   Write the data to i2c device.\n * param[in]\n *   start - the address which will write the data to.\n * param[in]\n *   pData - the head address of data array.\n * param[in]\n *   size - set the number of data will be written to the devide.\n * par Output\n *   None\n * \return\n *   Return the error code.\n *   the definition of the value of variable return_value:\n *   0:success\n *   1:BUFFER_LENGTH is shorter than size\n *   2:address send, nack received\n *   3:data send, nack received\n *   4:other twi error\n *   refer to the arduino official library twi.c\n * par Others\n *   Calling the official i2c library to read data.\n */\n  int8_t readData(uint8_t start, uint8_t *buffer, uint8_t size);\n\n/**\n * par Function\n *   writeData\n * par Description\n *   Write the data to i2c device.\n * param[in]\n *   start - the address which will write the data to.\n * param[in]\n *   pData - the head address of data array.\n * param[in]\n *   size - set the number of data will be written to the devide.\n * par Output\n *   None\n * \return\n *   Return the error code.\n *   the definition of the value of variable return_value:\n *   0:success\n *   1:BUFFER_LENGTH is shorter than size\n *   2:address send, nack received\n *   3:data send, nack received\n *   4:other twi error\n *   refer to the arduino official library twi.c\n * par Others\n *   Calling the official i2c library to write data.\n */\n  int8_t writeData(uint8_t start, const uint8_t *pData, uint8_t size);\n};\n#endif //  MeRGBLineFollower_H\n"}]},u={debug:["rgb_linefollower_rj25.rgb_linefollow_init","rgb_linefollower_rj25.rgb_linefollow_turning_sens","rgb_linefollower_rj25.rgb_linefollow_speed_diff","rgb_linefollower_rj25.rgb_linefollow_sensor_status","rgb_linefollower_rj25.rgb_linefollow_background_detect","rgb_linefollower_rj25.rgb_linefollow_set_color","rgb_linefollower_rj25.rgb_linefollow_get_data"],upload:[]},d=[],F=function(){var _=a(regeneratorRuntime.mark(function _(e,S){var O,L,R,t,r,o,i,n,E;return regeneratorRuntime.wrap(function(_){for(;;)switch(_.prev=_.next){case 0:if(_.prev=0,!(S&&S.workspace)){_.next=8;break}return"debug"===e?((O=S.workspace).enableBlocks.apply(O,N(u.upload)),(L=S.workspace).disableBlocks.apply(L,N(u.debug))):"upload"===e?((R=S.workspace).enableBlocks.apply(R,N(u.debug)),(t=S.workspace).disableBlocks.apply(t,N(u.upload))):((r=S.workspace).enableBlocks.apply(r,N(u.upload)),(o=S.workspace).enableBlocks.apply(o,N(u.debug))),i=S.getService("account"),_.next=6,i.isLogin();case 6:n=_.sent,n||(E=S.workspace).disableBlocks.apply(E,d);case 8:_.next=13;break;case 10:_.prev=10,_.t0=_["catch"](0);case 13:case"end":return _.stop();}},_,null,[[0,10]])}));return function(){return _.apply(this,arguments)}}(),p=[{lang:"arduinoc",template:"// generated by mBlock5 for RGB Linefollow\n// codes make you happy\n\n//( include //)\n\n//( lib //)\n\n//({\n    this.$ALL_VARIABLES.length==0?'':this.$ALL_VARIABLES.map(v=>\"float \"+v+\" = 0;\").join('\\n')\n}//)\n\n//( declare //)\n\nvoid _delay(float seconds) {\n  long endTime = millis() + seconds * 1000;\n  while(millis() < endTime) _loop();\n}\n\n//(\nvoid setup() {\n  //( setup //)\n  //( code //)\n}\n//)\n\nvoid _loop() {\n  //( _loop //)\n}\n\nvoid loop() {\n  //( loop //)\n  _loop();\n}",splitor:{frame:{left:"//(",right:"//)"},expression:{left:"/*{",right:"}*/"}},reducers:[{name:"include",reduce:function N(_){var e=[],S=!0,O=!1,L=void 0;try{for(var R,t=_[Symbol.iterator]();!(S=(R=t.next()).done);S=!0){var r=R.value,o="";"string"==typeof r?o=r:"function"==typeof r&&(o=r()),-1===e.indexOf(o)&&e.push(o)}}catch(_){O=!0,L=_}finally{try{S||null==t.return||t.return()}finally{if(O)throw L}}return 0===e.length?void 0:e.map(function(_){return"#include <"+_+">"}).join("\n")+"\n"}}]}],A={onLoad:function S(_,e){F(e.isUploadMode()?"upload":"debug",_,e)},onUnload:function _(){},onConnect:function _(){},onDisconnect:function _(){},onStopAll:function _(){},beforeChangeUploadMode:function _(){return a(regeneratorRuntime.mark(function _(){return regeneratorRuntime.wrap(function(_){for(;;)switch(_.prev=_.next){case 0:return _.abrupt("return",!0);case 1:case"end":return _.stop();}},_)}))()},beforeChangeDebugMode:function _(){return a(regeneratorRuntime.mark(function _(){return regeneratorRuntime.wrap(function(_){for(;;)switch(_.prev=_.next){case 0:return _.abrupt("return",!0);case 1:case"end":return _.stop();}},_)}))()},afterChangeUploadMode:function S(_,e){return F("upload",_,e),!0},afterChangeDebugMode:function S(_,e){return F("debug",_,e),!0},onSelect:function S(_,e){setTimeout(function(){F(e.isUploadMode()?"upload":"debug",_,e)},0)},onUnselect:function S(_,e){F("",_,e)},beforeCodeUpload:function _(){},afterCodeUpload:function _(){},onRead:function S(_,e){e.setTextDecoder("utf8"),_.log(e.readText())},onSignIn:function _(){},onSignOut:function _(){}},c=function(_){function e(){var _;return o(this,e),_=O(this,R(e).call(this)),_.funcs={rgbLinefollowInitHandler:{onRun:function _(){}},rgbLinefollowTurningSensCodesCode:function e(_){return 0>_.SENS&&(_.SENS=0),"\nLightSensorRGB_".concat(_.SENSOR_ID,".setKp(").concat(_.SENS,");")},rgbLinefollowTurningSensHandler:{onRun:function _(){}},rgbLinefollowSpeedDiffHandler:{onRun:function _(){},onMonitor:function _(){}},rgbLinefollowSensorStatusHandler:{onRun:function _(){},onMonitor:function _(){}},rgbLinefollowBackgroundDetectHandler:{onRun:function _(){},onMonitor:function _(){}},rgbLinefollowSetColorHandler:{onRun:function _(){}},rgbLinefollowGetDataHandler:{onRun:function _(){},onMonitor:function _(){}}},_}return t(e,_),S(e,[{key:"getInfo",value:function _(){return{id:"rgb_linefollower_rj25",targets:[{name:"auriga",options:{upload:{middlewares:[{name:"arduino",params:{sources:s.arduino}}]}}},{name:"mcore",options:{upload:{middlewares:[{name:"arduino",params:{sources:s.arduino}}]}}},{name:"megapipro",options:{upload:{middlewares:[{name:"arduino",params:{sources:s.arduino}}]}}},{name:"megapi",options:{upload:{middlewares:[{name:"arduino",params:{sources:s.arduino}}]}}},{name:"orion",options:{upload:{middlewares:[{name:"arduino",params:{sources:s.arduino}}]}}}],codeTypes:["arduinoc"],generators:p,categories:[{name:"rgb_linefollow_sensor",colors:["#4CBFE6","#31B5E2","#1EA8D7"],menuIconURI:"",blockIcon:null,blocks:[{opcode:"rgb_linefollow_init",blockType:"command",checkboxInFlyout:!1,hidden:!1,gap:12,arguments:{SENSOR_ID:{type:"fieldMenu",defaultValue:"1",menu:"RGB_LINEFOLLOW_INIT_SENSOR_ID"},PORT:{type:"fieldMenu",defaultValue:"1",menu:"RGB_LINEFOLLOW_INIT_PORT"}},branchCount:0,platform:["mblockpc","mblockweb"],codes:{arduinoc:{sections:{include:["\"src/MeRGBLineFollower.h\""],lib:"MeRGBLineFollower LightSensorRGB_/*{SENSOR_ID}*/(/*{PORT}*/, /*{SENSOR_ID}*/ - 1);",setup:"LightSensorRGB_/*{SENSOR_ID}*/.begin();\r\nLightSensorRGB_/*{SENSOR_ID}*/.updataAllSensorValue();",_loop:"LightSensorRGB_/*{SENSOR_ID}*/.loop();"}}},handler:this.funcs.rgbLinefollowInitHandler},{opcode:"rgb_linefollow_turning_sens",blockType:"command",checkboxInFlyout:!1,hidden:!1,gap:12,arguments:{SENSOR_ID:{type:"fieldMenu",defaultValue:"1",menu:"RGB_LINEFOLLOW_INIT_SENSOR_ID"},SENS:{type:"number",defaultValue:.3}},branchCount:0,platform:["mblockpc","mblockweb"],codes:{arduinoc:{code:this.funcs.rgbLinefollowTurningSensCodesCode,sections:{include:["\"src/MeRGBLineFollower.h\""]}}},handler:this.funcs.rgbLinefollowTurningSensHandler},{opcode:"rgb_linefollow_speed_diff",blockType:"number",checkboxInFlyout:!1,hidden:!1,gap:36,arguments:{SENSOR_ID:{type:"fieldMenu",defaultValue:"1",menu:"RGB_LINEFOLLOW_INIT_SENSOR_ID"}},branchCount:0,platform:["mblockpc","mblockweb"],codes:{arduinoc:{code:"LightSensorRGB_/*{SENSOR_ID}*/.getPositionOffset() / 511.0 * 100",sections:{include:["\"src/MeRGBLineFollower.h\""]}}},handler:this.funcs.rgbLinefollowSpeedDiffHandler},{opcode:"rgb_linefollow_sensor_status",blockType:"boolean",checkboxInFlyout:!1,hidden:!1,gap:12,arguments:{SENSOR_ID:{type:"fieldMenu",defaultValue:"1",menu:"RGB_LINEFOLLOW_INIT_SENSOR_ID"},SENSOR_STATUS:{type:"fieldMenu",defaultValue:"0",menu:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS"}},branchCount:0,platform:["mblockpc","mblockweb"],codes:{arduinoc:{code:"LightSensorRGB_/*{SENSOR_ID}*/.getPositionState() == /*{SENSOR_STATUS}*/",sections:{include:["\"src/MeRGBLineFollower.h\""]}}},handler:this.funcs.rgbLinefollowSensorStatusHandler},{opcode:"rgb_linefollow_background_detect",blockType:"boolean",checkboxInFlyout:!1,hidden:!1,gap:36,arguments:{SENSOR_ID:{type:"fieldMenu",defaultValue:"1",menu:"RGB_LINEFOLLOW_INIT_SENSOR_ID"},CHANNEL:{type:"fieldMenu",defaultValue:"1",menu:"RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL"}},branchCount:0,platform:["mblockpc","mblockweb"],codes:{arduinoc:{code:"LightSensorRGB_/*{SENSOR_ID}*/.getPositionState() & (0x01<<(/*{CHANNEL}*/ - 1))",sections:{include:["\"src/MeRGBLineFollower.h\""]}}},handler:this.funcs.rgbLinefollowBackgroundDetectHandler},{opcode:"rgb_linefollow_set_color",blockType:"command",checkboxInFlyout:!1,hidden:!1,gap:12,arguments:{SENSOR_ID:{type:"fieldMenu",defaultValue:"1",menu:"RGB_LINEFOLLOW_INIT_SENSOR_ID"},COLOR:{type:"fieldMenu",defaultValue:"1",menu:"RGB_LINEFOLLOW_SET_COLOR_COLOR"}},branchCount:0,platform:["mblockpc","mblockweb"],codes:{arduinoc:{code:"LightSensorRGB_/*{SENSOR_ID}*/.setRGBColour(/*{COLOR}*/);",sections:{include:["\"src/MeRGBLineFollower.h\""]}}},handler:this.funcs.rgbLinefollowSetColorHandler},{opcode:"rgb_linefollow_get_data",blockType:"number",checkboxInFlyout:!1,hidden:!1,gap:12,arguments:{SENSOR_ID:{type:"fieldMenu",defaultValue:"1",menu:"RGB_LINEFOLLOW_INIT_SENSOR_ID"},CHANNEL:{type:"fieldMenu",defaultValue:"1",menu:"RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL"}},branchCount:0,platform:["mblockpc","mblockweb"],codes:{arduinoc:{code:"LightSensorRGB_/*{SENSOR_ID}*/.getADCValueRGB/*{CHANNEL}*/()",sections:{include:["\"src/MeRGBLineFollower.h\""]}}},handler:this.funcs.rgbLinefollowGetDataHandler}],menus:{RGB_LINEFOLLOW_INIT_SENSOR_ID:[{text:"RGB_LINEFOLLOW_INIT_SENSOR_ID_0",value:"1"},{text:"RGB_LINEFOLLOW_INIT_SENSOR_ID_1",value:"2"},{text:"RGB_LINEFOLLOW_INIT_SENSOR_ID_2",value:"3"},{text:"RGB_LINEFOLLOW_INIT_SENSOR_ID_3",value:"4"}],RGB_LINEFOLLOW_INIT_PORT:[{text:"RGB_LINEFOLLOW_INIT_PORT_0",value:"1"},{text:"RGB_LINEFOLLOW_INIT_PORT_1",value:"2"},{text:"RGB_LINEFOLLOW_INIT_PORT_2",value:"3"},{text:"RGB_LINEFOLLOW_INIT_PORT_3",value:"4"},{text:"RGB_LINEFOLLOW_INIT_PORT_4",value:"5"},{text:"RGB_LINEFOLLOW_INIT_PORT_5",value:"6"},{text:"RGB_LINEFOLLOW_INIT_PORT_6",value:"7"},{text:"RGB_LINEFOLLOW_INIT_PORT_7",value:"8"},{text:"RGB_LINEFOLLOW_INIT_PORT_8",value:"9"},{text:"RGB_LINEFOLLOW_INIT_PORT_9",value:"10"},{text:"RGB_LINEFOLLOW_INIT_PORT_10",value:"11"},{text:"RGB_LINEFOLLOW_INIT_PORT_11",value:"12"}],RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS:[{text:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_0",value:"0"},{text:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_1",value:"1"},{text:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_2",value:"2"},{text:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_3",value:"3"},{text:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_4",value:"4"},{text:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_5",value:"5"},{text:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_6",value:"6"},{text:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_7",value:"7"},{text:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_8",value:"8"},{text:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_9",value:"9"},{text:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_10",value:"10"},{text:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_11",value:"11"},{text:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_12",value:"12"},{text:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_13",value:"13"},{text:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_14",value:"14"},{text:"RGB_LINEFOLLOW_SENSOR_STATUS_SENSOR_STATUS_15",value:"15"}],RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL:[{text:"RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_0",value:"1"},{text:"RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_1",value:"2"},{text:"RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_2",value:"3"},{text:"RGB_LINEFOLLOW_BACKGROUND_DETECT_CHANNEL_3",value:"4"}],RGB_LINEFOLLOW_SET_COLOR_COLOR:[{text:"RGB_LINEFOLLOW_SET_COLOR_COLOR_0",value:"1"},{text:"RGB_LINEFOLLOW_SET_COLOR_COLOR_1",value:"2"},{text:"RGB_LINEFOLLOW_SET_COLOR_COLOR_2",value:"3"}]}}],translationMap:G,snippets:B,excludeBlocks:[],generatorStartBlocks:[],version:"1.0.4",platform:["mblockpc","mblockweb"]}}},{key:"getHandler",value:function _(){return"object"===I(A)?A:"function"==typeof A?new A:void 0}}]),e}(function _(){o(this,_)});_.default=c});